#include "stdafx.h"
#include "Task.h"
#include "Duration.h"
#include "ProjectFile.h"
#include "listener\FieldListener.h"
#include "common\TaskFieldLists.h"
#include "common\DateHelper.h"
#include "common\StringHelper.h"
#include "RecurringTask.h"

/**
* Default constructor.
*
* @param file Parent file to which this record belongs.
* @param parent Parent task
*/
Task::Task(ProjectFile* file, Task* parent)
	:ProjectEntity(file), m_parent(NULL),
	m_array(TaskField::TF_FINISH + 1)
{
	setType(TaskType::FIXED_UNITS);
	setConstraintType(ConstraintType::AS_SOON_AS_POSSIBLE);
	setTaskMode(TaskMode::AUTO_SCHEDULED);
	setActive(true);

	m_parent = parent;

	if (file->getAutoTaskUniqueID() == true)
	{
		setUniqueID(file->getTaskUniqueID());
	}

	if (file->getAutoTaskID() == true)
	{
		setID(file->getTaskID());
	}

	if (file->getAutoWBS() == true)
	{
		generateWBS(parent);
	}

	if (file->getAutoOutlineNumber() == true)
	{
		generateOutlineNumber(parent);
	}

	if (file->getAutoOutlineLevel() == true)
	{
		if (parent == NULL)
		{
			setOutlineLevel(1);
		}
		else
		{
			setOutlineLevel(parent->getOutlineLevel() + 1);
		}
	}
}

Task::~Task()
{
	m_array.clear();
	m_children.RemoveAll();
	m_assignments.RemoveAll();
	m_listeners.RemoveAll();
	m_Allchildren.RemoveAll();
}

/**
* This method is used to automatically generate a value
* for the WBS field of this task.
*
* @param parent Parent Task*
*/
void Task::generateWBS(Task* parent)
{
	CString wbs;

	if (parent == NULL)
	{
		if (getUniqueID() == 0)
		{
			wbs = L"0";
		}
		else
		{
			wbs = Variant((int)getParentFile()->getChildTasks()->GetCount() + 1).toString();
		}
	}
	else
	{
		wbs = parent->getWBS();

		//
		// Apparently I added the next lines to support MPX files generated by Artemis, back in 2005
		// Unfortunately I have no test data which exercises this code, and it now breaks
		// otherwise valid WBS values read (in this case) from XER files. So it's commented out
		// until someone complains about their 2005-era Artemis MPX files not working!
		//
		//         int index = wbs.lastIndexOf(".0");
		//         if (index != -1)
		//         {
		//            wbs = wbs.substring(0, index);
		//         }

		int childTaskCount = parent->getChildTasks()->GetCount() + 1;
		if (wbs == L"0")
		{
			wbs = CStringToolkit::IntToStr(childTaskCount);
		}
		else
		{
			wbs += (CString(L".") + CStringToolkit::IntToStr(childTaskCount));
		}
	}

	setWBS(wbs);
}

/**
* This method is used to automatically generate a value
* for the Outline NumberPtr field of this task.
*
* @param parent Parent Task*
*/
void Task::generateOutlineNumber(Task* parent)
{
	CString outline;

	if (parent == NULL)
	{
		if (getUniqueID() == 0)
		{
			outline = "0";
		}
		else
		{
			outline = Variant((int)getParentFile()->getChildTasks()->GetCount() + 1).toString();
		}
	}
	else
	{
		outline = parent->getOutlineNumber();

		int index = StringHelper::lastIndexOf(outline, L".0");

		if (index != -1)
		{
			outline = outline.Mid(0, index);
		}

		int childTaskCount = parent->getChildTasks()->GetCount() + 1;
		if (outline == L"0")
		{
			outline = CStringToolkit::IntToStr(childTaskCount);
		}
		else
		{
			outline += (CString(".") + CStringToolkit::IntToStr(childTaskCount));
		}
	}

	setOutlineNumber(outline);
}

/**
* This method is used to add notes to the current task.
*
* @param notes notes to be added
*/
void Task::setNotes(CString notes)
{
	set(TaskField::TF_NOTES, VariantPtr(new Variant(notes)));
}

/**
* This method allows nested tasks to be added, with the WBS being
* completed automatically.
*
* @return new task
*/
Task* Task::addTask()
{
	ProjectFile* file = getParentFile();

	std::auto_ptr<Task> task(new Task(file, this));

	m_children.Add(task.get());

	file->addTask(task.get());

	setSummary(true);

	return task.release();
}

/**
* This method is used to associate a child task with the current
* task instance. It has package access, and has been designed to
* allow the hierarchical outline structure of tasks in an MPX
* file to be constructed as the file is read in.
*
* @param child Child task.
* @param childOutlineLevel Outline level of the child task.
*/
void Task::addChildTask(Task* child, int childOutlineLevel)
{
	int outlineLevel = getOutlineLevel();

	if ((outlineLevel + 1) == childOutlineLevel)
	{
		m_children.Add(child);
		setSummary(true);
	}
	else
	{
		if (m_children.isEmpty() == false)
		{
			(m_children.GetAt(m_children.GetCount() - 1))->addChildTask(child, childOutlineLevel);
		}
	}
}

/**
* This method is used to associate a child task with the current
* task instance. It has been designed to
* allow the hierarchical outline structure of tasks in an MPX
* file to be upDated once all of the task data has been read.
*
* @param child child task
*/
void Task::addChildTask(Task* child)
{
	child->m_parent = this;
	m_children.Add(child);
	setSummary(true);

	if (getParentFile()->getAutoOutlineLevel() == true)
	{
		child->setOutlineLevel(getOutlineLevel() + 1);
	}
}

/**
* Inserts a child task prior to a given sibling task.
*
* @param child new child task
* @param previousSibling sibling task
*/
void Task::addChildTaskBefore(Task* child, Task* previousSibling)
{
	int index = m_children.indexOf(previousSibling);
	if (index == -1)
	{
		m_children.Add(child);
	}
	else
	{
		m_children.InsertAt(index, child);
	}

	child->m_parent = this;
	setSummary(true);

	if (getParentFile()->getAutoOutlineLevel() == true)
	{
		child->setOutlineLevel(getOutlineLevel() + 1);
	}
}

/**
* Removes a child task.
*
* @param child child task instance
*/
void Task::removeChildTask(Task* child)
{
	if (m_children.remove(child))
	{
		child->m_parent = NULL;
	}
	setSummary(!m_children.isEmpty());
}

/**
* This method allows the list of child tasks to be cleared in preparation
* for the hierarchical task structure to be built.
*/
void Task::clearChildTasks()
{
	m_children.RemoveAll();
	setSummary(false);
}

/**
* This method allows recurring task details to be added to the
* current task.
*
* @return RecurringTask* object
*/
RecurringTaskPtr Task::addRecurringTask()
{
	if (!m_recurringTask)
	{
		m_recurringTask.reset(new RecurringTask());
	}

	return (m_recurringTask);
}

/**
* This method retrieves the recurring task record. If the current
* task is not a recurring task, then this method will return NULL.
*
* @return Recurring task record.
*/
RecurringTaskPtr Task::getRecurringTask()
{
	return (m_recurringTask);
}

/**
* This method allows a resource assignment to be added to the
* current task.
*
* @param resource the resource to assign
* @return Resource2AssignmentPtr object
*/
Resource2AssignmentPtr Task::addResource2Assignment(Resource2Ptr resource)
{
	Resource2AssignmentPtr assignment = getExistingResource2Assignment(resource);

	if (assignment == NULL)
	{
		assignment.reset(new Resource2Assignment(getParentFile(), this));
		m_assignments.Add(assignment);
		getParentFile()->addResource2Assignment(assignment);

		assignment->setTaskUniqueID(getUniqueID());
		assignment->setWork(getDuration());
		assignment->setUnits(NumberPtr(new Number(Resource2Assignment::DEFAULT_UNITS)));

		if (resource != NULL)
		{
			assignment->setResource2UniqueID(resource->getUniqueID());
			resource->addResource2Assignment(assignment);
		}
	}

	return (assignment);
}

/**
* Add a resource assignment which has been populated elsewhere.
*
* @param assignment resource assignment
*/
void Task::addResource2Assignment(Resource2AssignmentPtr assignment)
{
	if (getExistingResource2Assignment(assignment->getResource2()) == NULL)
	{
		m_assignments.Add(assignment);
		getParentFile()->addResource2Assignment(assignment);

		Resource2Ptr resource = assignment->getResource2();
		if (resource != NULL)
		{
			resource->addResource2Assignment(assignment);
		}
	}
}

/**
* Retrieves an existing resource assignment if one is present,
* to prevent duplicate resource assignments being added.
*
* @param resource resource to test for
* @return existing resource assignment
*/
Resource2AssignmentPtr Task::getExistingResource2Assignment(Resource2Ptr resource)
{
	Resource2AssignmentPtr assignment = NULL;
	int resourceUniqueID = 0;

	if (resource != NULL)
	{
		resourceUniqueID = resource->getUniqueID();
		for (size_t i = 0; i < m_assignments.GetCount(); i++)
		{
			Resource2AssignmentPtr assignment = m_assignments[i];
			NumberPtr uniqueID = assignment->getResource2UniqueID();
			if (uniqueID != NULL && uniqueID->intValue() == resourceUniqueID)
			{
				break;
			}
			assignment = NULL;
		}
	}

	return assignment;
}

/**
* This method allows the list of resource assignments for this
* task to be retrieved.
*
* @return list of resource assignments
*/
List<Resource2AssignmentPtr>* Task::getResource2Assignments()
{
	return &m_assignments;
}

/**
* Internal method used as part of the process of removing a
* resource assignment.
*
* @param assignment resource assignment to be removed
*/
void Task::removeResource2Assignment(Resource2AssignmentPtr assignment)
{
	m_assignments.remove(assignment);
}

/**
* This method allows a predecessor relationship to be added to this
* task instance.
*
* @param targetTask the predecessor task
* @param type relation type
* @param lag relation lag
* @return relationship
*/
RelationPtr Task::addPredecessor(Task* targetTask, RelationType type, DurationPtr lag)
{
	//
	// Ensure that we have a valid lag duration
	//
	if (!lag)
	{
		lag = Duration2::getInstance(0, TimeUnit::DAYS);
	}

	//
	// Retrieve the list of predecessors
	//

	std::shared_ptr<List<RelationPtr>> predecessorList =
		std::dynamic_pointer_cast<List<RelationPtr>> (getCachedValue(TaskField::TF_PREDECESSORS));

	if (!predecessorList)
	{
		predecessorList.reset(new List<RelationPtr>());
		set(TaskField::TF_PREDECESSORS, predecessorList);
	}

	//
	// Ensure that there is only one predecessor relationship between
	// these two tasks.
	//
	RelationPtr predecessorRelation;
	for (size_t i = 0; i < predecessorList->GetCount(); i++)
	{
		predecessorRelation = predecessorList->GetAt(i);

		if (predecessorRelation->getTargetTask() == targetTask)
		{
			if (predecessorRelation->getType() != type ||
				predecessorRelation->getLag()->compareTo(lag.get()) != 0)
			{
				predecessorRelation.reset();
			}
			break;
		}
		predecessorRelation.reset();
	}

	//
	// If necessary, create a new predecessor relationship
	//
	if (!predecessorRelation)
	{
		predecessorRelation.reset(new Relation(this, targetTask, type, lag));
		predecessorList->Add(predecessorRelation);
	}

	//
	// Retrieve the list of successors
	//
	std::shared_ptr<List<RelationPtr>> successorList =
		std::dynamic_pointer_cast<List<RelationPtr>>(
			targetTask->getCachedValue(TaskField::TF_SUCCESSORS));
	if (!successorList)
	{
		successorList.reset(new List<RelationPtr>());
		targetTask->set(TaskField::TF_SUCCESSORS, successorList);
	}

	//
	// Ensure that there is only one successor relationship between
	// these two tasks.
	//
	RelationPtr successorRelation;
	for (size_t i = 0; i < successorList->GetCount(); i++)
	{
		successorRelation = successorList->GetAt(i);
		if (successorRelation->getTargetTask() == this)
		{
			if (successorRelation->getType() != type ||
				successorRelation->getLag()->compareTo(lag.get()) != 0)
			{
				successorRelation = NULL;
			}
			break;
		}
		successorRelation = NULL;
	}

	//
	// If necessary, create a new successor relationship
	//
	if (!successorRelation)
	{
		successorRelation.reset(new Relation(targetTask, this, type, lag));
		successorList->Add(successorRelation);
	}

	return predecessorRelation;
}

/**
* The % Complete field contains the current status of a task, expressed
* as the percentage of the
* task's duration that has been completed. You can enter percent complete,
* or you can have
* Microsoft Project calculate it for you based on actual duration.
*
* @param val value to be set
*/
void Task::setPercentageComplete(NumberPtr val)
{
	set(TaskField::TF_PERCENT_COMPLETE, val);
}

/**
* The % Work Complete field contains the current status of a task,
* expressed as the
* percentage of the task's work that has been completed. You can enter
* percent work
* complete, or you can have Microsoft Project calculate it for you
* based on actual
* work on the task.
*
* @param val value to be set
*/
void Task::setPercentageWorkComplete(NumberPtr val)
{
	set(TaskField::TF_PERCENT_WORK_COMPLETE, val);
}

/**
* The Actual Cost field shows costs incurred for work already performed
* by all resources
* on a task, along with any other recorded costs associated with the task.
* You can enter
* all the actual costs or have Microsoft Project calculate them for you.
*
* @param val value to be set
*/
void Task::setActualCost(NumberPtr val)
{
	set(TaskField::TF_ACTUAL_COST, val);
}

/**
* The Actual DurationPtr field shows the span of actual working time for a
* task so far,
* based on the scheduled duration and current remaining work or
* completion percentage.
*
* @param val value to be set
*/
void Task::setActualDuration(DurationPtr val)
{
	set(TaskField::TF_ACTUAL_DURATION, val);
}

/**
* The Actual Finish field shows the DatePtr and time that a task actually
* finished.
* Microsoft Project sets the Actual Finish field to the scheduled finish
* DatePtr if
* the completion percentage is 100. This field contains "NA" until you
* enter actual
* information or set the completion percentage to 100.
*
* @param val value to be set
*/
void Task::setActualFinish(DatePtr val)
{
	set(TaskField::TF_ACTUAL_FINISH, val);
}

/**
* The Actual Start field shows the DatePtr and time that a task actually began.
* When a task is first created, the Actual Start field contains "NA." Once you
* enter the first actual work or a completion percentage for a task, Microsoft
* Project sets the actual start DatePtr to the scheduled start Date.
* @param val value to be set
*/
void Task::setActualStart(DatePtr val)
{
	set(TaskField::TF_ACTUAL_START, val);
}

/**
* The Actual Work field shows the amount of work that has already been
* done by the
* resources assigned to a task.
* @param val value to be set
*/
void Task::setActualWork(DurationPtr val)
{
	set(TaskField::TF_ACTUAL_WORK, val);
}

/**
* The Baseline Cost field shows the total planned cost for a task.
* Baseline cost is also referred to as budget at completion (BAC).
*
* @param val the amount to be set
*/
void Task::setBaselineCost(NumberPtr val)
{
	set(TaskField::TF_BASELINE_COST, val);
}

/**
* The Baseline DurationPtr field shows the original span of time planned to
* complete a task.
*
* @param val duration
*/
void Task::setBaselineDuration(DurationPtr val)
{
	set(TaskField::TF_BASELINE_DURATION, val);
}

/**
* The Baseline Finish field shows the planned completion DatePtr for a
* task at the time
* you saved a baseline. Information in this field becomes available
* when you set a
* baseline for a task.
*
* @param val DatePtr to be set
*/
void Task::setBaselineFinish(DatePtr val)
{
	set(TaskField::TF_BASELINE_FINISH, val);
}

/**
* The Baseline Start field shows the planned beginning DatePtr for a task at
* the time
* you saved a baseline. Information in this field becomes available when you
* set a baseline.
*
* @param val DatePtr to be set
*/
void Task::setBaselineStart(DatePtr val)
{
	set(TaskField::TF_BASELINE_START, val);
}

/**
* The Baseline Work field shows the originally planned amount of work to
* be performed
* by all resources assigned to a task. This field shows the planned
* person-hours
* scheduled for a task. Information in the Baseline Work field
* becomes available
* when you set a baseline for the project.
*
* @param val the duration to be set.
*/
void Task::setBaselineWork(DurationPtr val)
{
	set(TaskField::TF_BASELINE_WORK, val);
}

/**
* The BCWP (budgeted cost of work performed) field contains the
* cumulative value
* of the assignment's timephased percent complete multiplied by
* the assignments
* timephased baseline cost. BCWP is calculated up to the status
* DatePtr or todays
* Date. This information is also known as earned value.
*
* @param val the amount to be set
*/
void Task::setBCWP(NumberPtr val)
{
	set(TaskField::TF_BCWP, val);
}

/**
* The BCWS (budgeted cost of work scheduled) field contains the cumulative
* timephased baseline costs up to the status DatePtr or today's Date.
*
* @param val the amount to set
*/
void Task::setBCWS(NumberPtr val)
{
	set(TaskField::TF_BCWS, val);
}

/**
* The Confirmed field indicates whether all resources assigned to a task have
* accepted or rejected the task assignment in response to a TeamAssign message
* regarding their assignments.
*
* @param val bool value
*/
void Task::setConfirmed(bool val)
{
	set(TaskField::TF_CONFIRMED, VariantPtr(new Variant(val)));
}

/**
* The Constraint DatePtr field shows the specific DatePtr associated with certain
* constraint types,
*  such as Must Start On, Must Finish On, Start No Earlier Than,
*  Start No Later Than,
*  Finish No Earlier Than, and Finish No Later Than.
*  SEE class constants
*
* @param val DatePtr to be set
*/
void Task::setConstraintDate(DatePtr val)
{
	set(TaskField::TF_CONSTRAINT_DATE, val);
}

/**
* Private method for dealing with string parameters from File.
*
* @param type string constraint type
*/
void Task::setConstraintType(ConstraintType type)
{
	set(TaskField::TF_CONSTRAINT_TYPE, VariantPtr(new Variant((int)type)));
}

/**
* The Contact field contains the name of an individual
* responsible for a task.
*
* @param val value to be set
*/
void Task::setContact(CString val)
{
	set(TaskField::TF_CONTACT, VariantPtr(new Variant(val)));
}

/**
* The Cost field shows the total scheduled, or projected, cost for a task,
* based on costs already incurred for work performed by all resources assigned
* to the task, in addition to the costs planned for the remaining work for the
* assignment. This can also be referred to as estimate at completion (EAC).
*
* @param val amount
*/
void Task::setCost(NumberPtr val)
{
	set(TaskField::TF_COST, val);
}

/**
* Set a cost value.
*
* @param index cost index (1-10)
* @param value cost value
*/
void Task::setCost(int index, NumberPtr value)
{
	set(selectField(TaskFieldLists::CUSTOM_COST, index), value);
}

/**
* Retrieve a cost value.
*
* @param index cost index (1-10)
* @return cost value
*/
NumberPtr Task::getCost(int index)
{
	return std::dynamic_pointer_cast<Number> (getCachedValue(selectField(TaskFieldLists::CUSTOM_COST, index)));
}

/**
* The Cost Variance field shows the difference between the
* baseline cost and total cost for a task. The total cost is the
* current estimate of costs based on actual costs and remaining costs.
*
* @param val amount
*/
void Task::setCostVariance(NumberPtr val)
{
	set(TaskField::TF_COST_VARIANCE, val);
}

/**
* The Created field contains the DatePtr and time when a task was
* added to the project.
*
* @param val Date
*/
void Task::setCreateDate(DatePtr val)
{
	set(TaskField::TF_CREATED, val);
}

/**
* The Critical field indicates whether a task has any room in the
* schedule to slip,
* or if a task is on the critical path. The Critical field contains
* Yes if the task
* is critical and No if the task is not critical.
*
* @param val whether task is critical or not
*/
void Task::setCritical(bool val)
{
	set(TaskField::TF_CRITICAL, VariantPtr(new Variant(val)));
}

/**
* The CV (earned value cost variance) field shows the difference
* between how much it should have cost to achieve the current level of
* completion on the task, and how much it has actually cost to achieve the
* current level of completion up to the status DatePtr or today's Date.
*
* @param val value to set
*/
void Task::setCV(NumberPtr val)
{
	set(TaskField::TF_CV, val);
}

/**
* Set amount of delay as elapsed real time.
*
* @param val elapsed time
*/
void Task::setLevelingDelay(DurationPtr val)
{
	set(TaskField::TF_LEVELING_DELAY, val);
}

/**
* The DurationPtr field is the total span of active working time for a task.
* This is generally the amount of time from the start to the finish of a task.
* The default for new tasks is 1 day (1d).
*
* @param val duration
*/
void Task::setDuration(DurationPtr val)
{
	set(TaskField::TF_DURATION, val);
}

/**
* Set the duration text used for a manually scheduled task.
*
* @param val text
*/
void Task::setDurationText(CString val)
{
	set(TaskField::TF_DURATION_TEXT, VariantPtr(new Variant(val)));
}

/**
* Set the manual duration attribute.
*
* @param dur manual duration
*/
void Task::setManualDuration(DurationPtr dur)
{
	set(TaskField::TF_MANUAL_DURATION, dur);
}

/**
* Read the manual duration attribute.
*
* @return manual duration
*/
DurationPtr Task::getManualDuration()
{
	return std::dynamic_pointer_cast<Duration2>(getCachedValue(TaskField::TF_MANUAL_DURATION));
}

/**
* The DurationPtr Variance field contains the difference between the
* baseline duration of a task and the forecast or actual duration
* of the task.
*
* @param duration duration value
*/
void Task::setDurationVariance(DurationPtr duration)
{
	set(TaskField::TF_DURATION_VARIANCE, duration);
}

/**
* The Early Finish field contains the earliest DatePtr that a task
* could possibly finish, based on early finish Dates of predecessor
* and successor tasks, other constraints, and any leveling delay.
*
* @param DatePtr DatePtr value
*/
void Task::setEarlyFinish(DatePtr date)
{
	set(TaskField::TF_EARLY_FINISH, date);
}

/**
* The Early Start field contains the earliest DatePtr that a task could
* possibly begin, based on the early start Dates of predecessor and
* successor tasks, and other constraints.
*
* @param DatePtr DatePtr value
*/
void Task::setEarlyStart(DatePtr date)
{
	set(TaskField::TF_EARLY_START, date);
}

/**
* The Finish field shows the DatePtr and time that a task is scheduled to be
* completed. MS project allows a finish DatePtr to be entered, and will
* calculate the duration, or a duration can be supplied and MS Project
* will calculate the finish Date.
*
* @param DatePtr DatePtr value
*/
void Task::setFinish(DatePtr date)
{
	set(TaskField::TF_FINISH, date);
}

/**
* Set the finish text used for a manually scheduled task.
*
* @param val text
*/
void Task::setFinishText(CString val)
{
	set(TaskField::TF_FINISH_TEXT, VariantPtr(new Variant(val)));
}

/**
* The Finish Variance field contains the amount of time that represents the
* difference between a task's baseline finish DatePtr and its forecast
* or actual finish Date.
*
* @param duration duration value
*/
void Task::setFinishVariance(DurationPtr duration)
{
	set(TaskField::TF_FINISH_VARIANCE, duration);
}

/**
* The Fixed Cost field shows any task expense that is not associated
* with a resource cost.
*
* @param val amount
*/
void Task::setFixedCost(NumberPtr val)
{
	set(TaskField::TF_FIXED_COST, val);
}

/**
* The Free Slack field contains the amount of time that a task can be
* delayed without delaying any successor tasks. If the task has no
* successors, free slack is the amount of time that a task can be delayed
* without delaying the entire project's finish Date.
*
* @param duration duration value
*/
void Task::setFreeSlack(DurationPtr duration)
{
	set(TaskField::TF_FREE_SLACK, duration);
}

/**
* The Hide Bar flag indicates whether the Gantt bars and CalendarPtr bars
* for a task are hidden when this project's data is displayed in MS Project.
*
* @param flag bool value
*/
void Task::setHideBar(bool flag)
{
	set(TaskField::TF_HIDE_BAR, VariantPtr(new Variant(flag)));
}

/**
* The ID field contains the identifier number that Microsoft Project
* automatically assigns to each task as you add it to the project.
* The ID indicates the position of a task with respect to the other tasks.
*
* @param val ID
*/
void Task::setID(int val)
{
	ProjectFile* parent = getParentFile();
	int previous = getID();

	if (previous != -1)
	{
		parent->unmapTaskID(previous);
	}

	parent->mapTaskID(val, this);

	set(TaskField::TF_ID, VariantPtr(new Variant(val)));
}

/**
* The Late Finish field contains the latest DatePtr that a task can finish
* without delaying the finish of the project. This DatePtr is based on the
* task's late start Date, as well as the late start and late finish Dates
* of predecessor and successor tasks, and other constraints.
*
* @param DatePtr DatePtr value
*/
void Task::setLateFinish(DatePtr Date)
{
	set(TaskField::TF_LATE_FINISH, Date);
}

/**
* The Late Start field contains the latest DatePtr that a task can start
* without delaying the finish of the project. This DatePtr is based on the
* task's start Date, as well as the late start and late finish Dates of
* predecessor and successor tasks, and other constraints.
*
* @param DatePtr DatePtr value
*/
void Task::setLateStart(DatePtr Date)
{
	set(TaskField::TF_LATE_START, Date);
}

/**
* The Linked Fields field indicates whether there are OLE links to the task,
* either from elsewhere in the active project, another Microsoft Project
* file, or from another program.
*
* @param flag bool value
*/
void Task::setLinkedFields(bool flag)
{
	set(TaskField::TF_LINKED_FIELDS, VariantPtr(new Variant(flag)));
}

/**
* This is a user defined field used to mark a task for some form of
* additional action.
*
* @param flag bool value
*/
void Task::setMarked(bool flag)
{
	set(TaskField::TF_MARKED, VariantPtr(new Variant(flag)));
}

/**
* The Milestone field indicates whether a task is a milestone.
*
* @param flag bool value
*/
void Task::setMilestone(bool flag)
{
	set(TaskField::TF_MILESTONE, VariantPtr(new Variant(flag)));
}

/**
* The Name field contains the name of a task.
*
* @param name task name
*/
void Task::setName(CString name)
{
	set(TaskField::TF_NAME, VariantPtr(new Variant(name)));
}

/**
* The Objects field contains the number of objects attached to a task.
*
* @param val - integer value
*/
void Task::setObjects(int val)
{
	set(TaskField::TF_OBJECTS, VariantPtr(new Variant(val)));
}

/**
* The Outline Level field contains the number that indicates the level of
* the task in the project outline hierarchy.
*
* @param val - int
*/
void Task::setOutlineLevel(int val)
{
	set(TaskField::TF_OUTLINE_LEVEL, VariantPtr(new Variant(val)));
}

/**
* The Outline NumberPtr field contains the number of the task in the structure
* of an outline. This number indicates the task's position within the
* hierarchical structure of the project outline. The outline number is
* similar to a WBS (work breakdown structure) number, except that the
* outline number is automatically entered by Microsoft Project.
*
* @param val - text
*/
void Task::setOutlineNumber(CString val)
{
	set(TaskField::TF_OUTLINE_NUMBER, VariantPtr(new Variant(val)));
}

/**
* The PriorityPtr field provides choices for the level of importance
* assigned to a task, which in turn indicates how readily a task can be
* delayed or split during resource leveling.
* The default priority is Medium. Those tasks with a priority
* of Do Not Level are never delayed or split when Microsoft Project levels
* tasks that have overallocated resources assigned.
*
* @param priority the priority value
*/
void Task::setPriority(PriorityPtr priority)
{
	set(TaskField::TF_PRIORITY, priority);
}

/**
* The Project field shows the name of the project from which a
* task originated.
* This can be the name of the active project file-> If there are
* other projects
* inserted into the active project file, the name of the
* inserted project appears
* in this field for the task.
*
* @param val - text
*/
void Task::setProject(CString val)
{
	set(TaskField::TF_PROJECT, VariantPtr(new Variant(val)));
}

/**
* The Remaining Cost field shows the remaining scheduled expense of a task that
* will be incurred in completing the remaining scheduled work by all resources
* assigned to the task.
*
* @param val - currency amount
*/
void Task::setRemainingCost(NumberPtr val)
{
	set(TaskField::TF_REMAINING_COST, val);
}

/**
* The Remaining DurationPtr field shows the amount of time required to complete
* the unfinished portion of a task.
*
* @param val - duration.
*/
void Task::setRemainingDuration(DurationPtr val)
{
	set(TaskField::TF_REMAINING_DURATION, val);
}

/**
* The Remaining Work field shows the amount of time, or person-hours,
* still required by all assigned resources to complete a task.
* @param val  - duration
*/
void Task::setRemainingWork(DurationPtr val)
{
	set(TaskField::TF_REMAINING_WORK, val);
}

/**
* The Resource2Ptr Group2 field contains the list of resource groups to which the
* resources assigned to a task belong.
*
* @param val - CString list
*/
void Task::setResource2Group2(CString val)
{
	set(TaskField::TF_RESOURCE_GROUP, VariantPtr(new Variant(val)));
}

/**
* The Resource2Ptr Initials field lists the abbreviations for the names of
* resources assigned to a task. These initials can serve as substitutes
* for the names.
*
* Note that MS Project 98 does no normally populate this field when
* it generates an MPX file, and will therefore not expect to see values
* in this field when it reads an MPX file-> Supplying values for this
* field will cause MS Project 98, 2000, and 2002 to create new resources
* and ignore any other resource assignments that have been defined
* in the MPX file->
*
* @param val CString containing a comma separated list of initials
*/
void Task::setResource2Initials(CString val)
{
	set(TaskField::TF_RESOURCE_INITIALS, VariantPtr(new Variant(val)));
}

/**
* The Resource2Ptr Names field lists the names of all resources
* assigned to a task.
*
* Note that MS Project 98 does not normally populate this field when
* it generates an MPX file, and will therefore not expect to see values
* in this field when it reads an MPX file-> Supplying values for this
* field when writing an MPX file will cause MS Project 98, 2000, and 2002
* to create new resources and ignore any other resource assignments
* that have been defined in the MPX file->
*
* @param val CString containing a comma separated list of names
*/
void Task::setResource2Names(CString val)
{
	set(TaskField::TF_RESOURCE_NAMES, VariantPtr(new Variant(val)));
}

/**
* The Resume field shows the DatePtr that the remaining portion of a task is
* scheduled to resume after you enter a new value for the % Complete field.
* The Resume field is also recalculated when the remaining portion of a task
* is moved to a new Date.
*
* @param val - Date
*/
void Task::setResume(DatePtr val)
{
	set(TaskField::TF_RESUME, val);
}

/**
* For subtasks, the Rollup field indicates whether information on the subtask
* Gantt bars will be rolled up to the summary task bar. For summary tasks, the
* Rollup field indicates whether the summary task bar displays rolled up bars.
* You must have the Rollup field for summary tasks set to Yes for any subtasks
* to roll up to them.
*
* @param val - bool
*/
void Task::setRollup(bool val)
{
	set(TaskField::TF_ROLLUP, VariantPtr(new Variant(val)));
}

/**
* The Start field shows the DatePtr and time that a task is scheduled to begin.
* You can enter the start DatePtr you want, to indicate the DatePtr when the task
* should begin. Or, you can have Microsoft Project calculate the start Date.
* @param val - Date
*/
void Task::setStart(DatePtr val)
{
	set(TaskField::TF_START, val);
}

/**
* Set the start text used for a manually scheduled task.
*
* @param val text
*/
void Task::setStartText(CString val)
{
	set(TaskField::TF_START_TEXT, VariantPtr(new Variant(val)));
}

/**
* The Start Variance field contains the amount of time that represents the
* difference between a task's baseline start DatePtr and its currently
* scheduled start Date.
*
* @param val - duration
*/
void Task::setStartVariance(DurationPtr val)
{
	set(TaskField::TF_START_VARIANCE, val);
}

/**
* The Stop field shows the DatePtr that represents the end of the actual
* portion of a task. Typically, Microsoft Project calculates the stop Date.
* However, you can edit this DatePtr as well.
*
* @param val - Date
*/
void Task::setStop(DatePtr val)
{
	set(TaskField::TF_STOP, val);
}

/**
* The Subproject File field contains the name of a project inserted into
* the active project file-> The Subproject File field contains the inserted
* project's path and file name.
*
* @param val - CString
*/
void Task::setSubprojectName(CString val)
{
	set(TaskField::TF_SUBPROJECT_FILE, VariantPtr(new Variant(val)));
}

/**
* The Summary field indicates whether a task is a summary task.
*
* @param val - bool
*/
void Task::setSummary(bool val)
{
	set(TaskField::TF_SUMMARY, VariantPtr(new Variant(val)));
}

/**
* The SV (earned value schedule variance) field shows the difference
* in cost terms between the current progress and the baseline plan
* of the task up to the status DatePtr or today's Date. You can use SV
* to check costs to determine whether tasks are on schedule.
* @param val - currency amount
*/
void Task::setSV(NumberPtr val)
{
	set(TaskField::TF_SV, val);
}

/**
* The Total Slack field contains the amount of time a task can be delayed
* without delaying the project's finish Date.
*
* @param val - duration
*/
void Task::setTotalSlack(DurationPtr val)
{
	set(TaskField::TF_TOTAL_SLACK, val);
}

/**
* The Unique ID field contains the number that Microsoft Project
* automatically designates whenever a new task is created.
* This number indicates the sequence in which the task was created,
* regardless of placement in the schedule.
*
* @param val unique ID
*/
void Task::setUniqueID(int val)
{
	ProjectFile* parent = getParentFile();
	int previous = getUniqueID();

	if (previous != NULL)
	{
		parent->unmapTaskUniqueID(previous);
	}

	parent->mapTaskUniqueID(val, this);

	set(TaskField::TF_UNIQUE_ID, VariantPtr(new Variant(val)));
}

/**
* The UpDate Needed field indicates whether a TeamUpDate message should
* be sent to the assigned resources because of changes to the start Date,
* finish Date, or resource reassignments of the task.
*
* @param val - bool
*/
void Task::setUpDateNeeded(bool val)
{
	set(TaskField::TF_UPDATE_NEEDED, VariantPtr(new Variant(val)));
}

/**
* The work breakdown structure code. The WBS field contains an alphanumeric
* code you can use to represent the task's position within the hierarchical
* structure of the project. This field is similar to the outline number,
* except that you can edit it.
*
* @param val - CString
*/
void Task::setWBS(CString val)
{
	set(TaskField::TF_WBS, VariantPtr(new Variant(val)));
}

/**
* The Work field shows the total amount of work scheduled to be performed
* on a task by all assigned resources. This field shows the total work,
* or person-hours, for a task.
*
* @param val - duration
*/
void Task::setWork(DurationPtr val)
{
	set(TaskField::TF_WORK, val);
}

/**
* The Work Variance field contains the difference between a task's baseline
* work and the currently scheduled work.
*
* @param val - duration
*/
void Task::setWorkVariance(DurationPtr val)
{
	set(TaskField::TF_WORK_VARIANCE, val);
}

/**
* The % Complete field contains the current status of a task,
* expressed as the percentage of the task's duration that has been completed.
* You can enter percent complete, or you can have Microsoft Project calculate
* it for you based on actual duration.
* @return percentage as float
*/
NumberPtr Task::getPercentageComplete()
{
	return std::dynamic_pointer_cast<Number>(getCachedValue(TaskField::TF_PERCENT_COMPLETE));
}

/**
* The % Work Complete field contains the current status of a task,
* expressed as the percentage of the task's work that has been completed.
* You can enter percent work complete, or you can have Microsoft Project
* calculate it for you based on actual work on the task.
*
* @return percentage as float
*/
NumberPtr Task::getPercentageWorkComplete()
{
	return std::dynamic_pointer_cast<Number>(getCachedValue(TaskField::TF_PERCENT_WORK_COMPLETE));
}

/**
* The Actual Cost field shows costs incurred for work already performed
* by all resources on a task, along with any other recorded costs associated
* with the task. You can enter all the actual costs or have Microsoft Project
* calculate them for you.
*
* @return currency amount as float
*/
NumberPtr Task::getActualCost()
{
	return std::dynamic_pointer_cast<Number>(getCachedValue(TaskField::TF_ACTUAL_COST));
}

/**
* The Actual DurationPtr field shows the span of actual working time for a
* task so far, based on the scheduled duration and current remaining work
* or completion percentage.
*
* @return duration string
*/
DurationPtr Task::getActualDuration()
{
	return std::dynamic_pointer_cast<Duration2>(getCachedValue(TaskField::TF_ACTUAL_DURATION));
}

/**
* The Actual Finish field shows the DatePtr and time that a task actually
* finished. Microsoft Project sets the Actual Finish field to the scheduled
* finish DatePtr if the completion percentage is 100. This field contains "NA"
* until you enter actual information or set the completion percentage to 100.
* If "NA" is entered as value, arbitrary year zero DatePtr is used. Date(0);
*
* @return Date
*/
DatePtr Task::getActualFinish()
{
	return std::dynamic_pointer_cast<Date>(getCachedValue(TaskField::TF_ACTUAL_FINISH));
}

/**
* The Actual Start field shows the DatePtr and time that a task actually began.
* When a task is first created, the Actual Start field contains "NA." Once
* you enter the first actual work or a completion percentage for a task,
* Microsoft Project sets the actual start DatePtr to the scheduled start Date.
* If "NA" is entered as value, arbitrary year zero DatePtr is used. Date(0);
*
* @return Date
*/
DatePtr Task::getActualStart()
{
	return std::dynamic_pointer_cast<Date>(getCachedValue(TaskField::TF_ACTUAL_START));
}

/**
* The Actual Work field shows the amount of work that has already been done
* by the resources assigned to a task.
*
* @return duration string
*/
DurationPtr Task::getActualWork()
{
	return std::dynamic_pointer_cast<Duration2>(getCachedValue(TaskField::TF_ACTUAL_WORK));
}

/**
* The Baseline Cost field shows the total planned cost for a task.
* Baseline cost is also referred to as budget at completion (BAC).
* @return currency amount as float
*/
NumberPtr Task::getBaselineCost()
{
	return std::dynamic_pointer_cast<Number>(getCachedValue(TaskField::TF_BASELINE_COST));
}

/**
* The Baseline DurationPtr field shows the original span of time planned
* to complete a task.
*
* @return  - duration string
*/
DurationPtr Task::getBaselineDuration()
{
	ObjectPtr result = getCachedValue(TaskField::TF_BASELINE_DURATION);
	if (!result)
	{
		result = getCachedValue(TaskField::TF_BASELINE_ESTIMATED_DURATION);
	}

	return std::dynamic_pointer_cast<Duration2>(result);
	//if (!(result instanceof Duration))
	//{
	//    result = NULL;
	//}
	//return (Duration) result;
}

/**
* Retrieves the text value for the baseline duration.
*
* @return baseline duration text
*/
CString Task::getBaselineDurationText()
{
	ObjectPtr result = getCachedValue(TaskField::TF_BASELINE_DURATION);
	if (!result)
	{
		result = getCachedValue(TaskField::TF_BASELINE_ESTIMATED_DURATION);
	}

	return NumberHelper::getString(result);

	//if (!(result instanceof CString))
	//{
	//    result = NULL;
	//}
	//return (CString) result;
}

/**
* Sets the baseline duration text value.
*
* @param value baseline duration text
*/
void Task::setBaselineDurationText(CString value)
{
	set(TaskField::TF_BASELINE_DURATION, VariantPtr(new Variant(value)));
}

/**
* The Baseline Finish field shows the planned completion DatePtr for a task
* at the time you saved a baseline. Information in this field becomes
* available when you set a baseline for a task.
*
* @return Date
*/
DatePtr Task::getBaselineFinish()
{
	ObjectPtr result = getCachedValue(TaskField::TF_BASELINE_FINISH);
	if (result == NULL)
	{
		result = getCachedValue(TaskField::TF_BASELINE_ESTIMATED_FINISH);
	}

	return std::dynamic_pointer_cast<Date>(result);

	//if (!(result instanceof Date))
	//{
	//    result = NULL;
	//}
	//return (Date) result;
}

/**
* Retrieves the baseline finish text value.
*
* @return baseline finish text
*/
CString Task::getBaselineFinishText()
{
	ObjectPtr result = getCachedValue(TaskField::TF_BASELINE_FINISH);
	if (result == NULL)
	{
		result = getCachedValue(TaskField::TF_BASELINE_ESTIMATED_FINISH);
	}

	return NumberHelper::getString(result);

	//if (!(result instanceof CString))
	//{
	//    result = NULL;
	//}
	//return (CString) result;
}

/**
* Sets the baseline finish text value.
*
* @param value baseline finish text
*/
void Task::setBaselineFinishText(CString value)
{
	set(TaskField::TF_BASELINE_FINISH, VariantPtr(new Variant(value)));
}

/**
* The Baseline Start field shows the planned beginning DatePtr for a task at
* the time you saved a baseline. Information in this field becomes available
* when you set a baseline.
*
* @return Date
*/
DatePtr Task::getBaselineStart()
{
	ObjectPtr result = getCachedValue(TaskField::TF_BASELINE_START);
	if (result == NULL)
	{
		result = getCachedValue(TaskField::TF_BASELINE_ESTIMATED_START);
	}

	return std::dynamic_pointer_cast<Date>(result);

	//if (!(result instanceof Date))
	//{
	//    result = NULL;
	//}
	//return (Date) result;
}

/**
* Retrieves the baseline start text value.
*
* @return baseline start value
*/
CString Task::getBaselineStartText()
{
	ObjectPtr result = getCachedValue(TaskField::TF_BASELINE_START);
	if (!result)
	{
		result = getCachedValue(TaskField::TF_BASELINE_ESTIMATED_START);
	}

	return NumberHelper::getString(result);

	//if (!(result instanceof CString))
	//{
	//    result = NULL;
	//}
	//return (CString) result;
}

/**
* Sets the baseline start text value.
*
* @param value baseline start text
*/
void Task::setBaselineStartText(CString value)
{
	set(TaskField::TF_BASELINE_START, VariantPtr(new Variant(value)));
}

/**
* The Baseline Work field shows the originally planned amount of work to be
* performed by all resources assigned to a task. This field shows the planned
* person-hours scheduled for a task. Information in the Baseline Work field
* becomes available when you set a baseline for the project.
*
* @return Duration
*/
DurationPtr Task::getBaselineWork()
{
	return std::dynamic_pointer_cast<Duration2>(getCachedValue(TaskField::TF_BASELINE_WORK));
}

/**
* The BCWP (budgeted cost of work performed) field contains
* the cumulative value of the assignment's timephased percent complete
* multiplied by the assignment's timephased baseline cost.
* BCWP is calculated up to the status DatePtr or today's Date.
* This information is also known as earned value.
*
* @return currency amount as float
*/
NumberPtr Task::getBCWP()
{
	return std::dynamic_pointer_cast<Number>(getCachedValue(TaskField::TF_BCWP));
}

/**
* The BCWS (budgeted cost of work scheduled) field contains the cumulative
* timephased baseline costs up to the status DatePtr or today's Date.
*
* @return currency amount as float
*/
NumberPtr Task::getBCWS()
{
	return std::dynamic_pointer_cast<Number>(getCachedValue(TaskField::TF_BCWS));
}

/**
* The Confirmed field indicates whether all resources assigned to a task
* have accepted or rejected the task assignment in response to a TeamAssign
* message regarding their assignments.
*
* @return bool
*/
bool Task::getConfirmed()
{
	return NumberHelper::getBool(getCachedValue(TaskField::TF_CONFIRMED));
}

/**
* The Constraint DatePtr field shows the specific DatePtr associated with certain
* constraint types, such as Must Start On, Must Finish On,
* Start No Earlier Than,
* Start No Later Than, Finish No Earlier Than, and Finish No Later Than.
*
* @return Date
*/
DatePtr Task::getConstraintDate()
{
	return std::dynamic_pointer_cast<Date>(getCachedValue(TaskField::TF_CONSTRAINT_DATE));
}

/**
* The Constraint Type field provides choices for the type of constraint you
* can apply for scheduling a task.
*
* @return constraint type
*/
ConstraintType Task::getConstraintType()
{
	return (ConstraintType)NumberHelper::getInt(getCachedValue(TaskField::TF_CONSTRAINT_TYPE));
}

/**
* The Contact field contains the name of an individual
* responsible for a task.
*
* @return CString
*/
CString Task::getContact()
{
	return NumberHelper::getString(getCachedValue(TaskField::TF_CONTACT));
}

/**
* The Cost field shows the total scheduled, or projected, cost for a task,
* based on costs already incurred for work performed by all resources assigned
* to the task, in addition to the costs planned for the remaining work for the
* assignment. This can also be referred to as estimate at completion (EAC).
*
* @return cost amount
*/
NumberPtr Task::getCost()
{
	return std::dynamic_pointer_cast<Number>(getCachedValue(TaskField::TF_COST));
}

/**
* The Cost Variance field shows the difference between the baseline cost
* and total cost for a task. The total cost is the current estimate of costs
* based on actual costs and remaining costs.
*
* @return amount
*/
NumberPtr Task::getCostVariance()
{
	NumberPtr variance = std::dynamic_pointer_cast<Number>(getCachedValue(TaskField::TF_COST_VARIANCE));
	if (variance == NULL)
	{
		NumberPtr cost = getCost();
		NumberPtr baselineCost = getBaselineCost();
		if (cost != NULL && baselineCost != NULL)
		{
			variance = VariantPtr(new Variant(cost->doubleValue() - baselineCost->doubleValue()));
			set(TaskField::TF_COST_VARIANCE, variance);
		}
	}
	return (variance);
}

/**
* The Created field contains the DatePtr and time when a task was added
* to the project.
*
* @return Date
*/
DatePtr Task::getCreateDate()
{
	return std::dynamic_pointer_cast<Date>(getCachedValue(TaskField::TF_CREATED));
}

/**
* The Critical field indicates whether a task has any room in the schedule
* to slip, or if a task is on the critical path. The Critical field contains
* Yes if the task is critical and No if the task is not critical.
*
* @return bool
*/
bool Task::getCritical()
{
	ObjectPtr critical = getCachedValue(TaskField::TF_CRITICAL);
	if (critical == NULL)
	{
		DurationPtr totalSlack = getTotalSlack();
		bool critical2 = (totalSlack->getDuration() <= 0 && NumberHelper::getInt(getPercentageComplete()) != 100 &&
			((getTaskMode() == TaskMode::AUTO_SCHEDULED) ||
			(getDurationText().GetLength() == 0 &&
				getStartText().GetLength() == 0 && getFinishText().GetLength() == 0)));

		critical = VariantPtr(new Variant(critical2));
		set(TaskField::TF_CRITICAL, std::dynamic_pointer_cast<Variant>(critical));
	}
	return (std::dynamic_pointer_cast<Variant>(critical))->boolValue();
}

/**
* The CV (earned value cost variance) field shows the difference between
* how much it should have cost to achieve the current level of completion
* on the task, and how much it has actually cost to achieve the current
* level of completion up to the status DatePtr or today's Date.
* How Calculated   CV is the difference between BCWP
* (budgeted cost of work performed) and ACWP
* (actual cost of work performed). Microsoft Project calculates
* the CV as follows: CV = BCWP - ACWP
*
* @return sum of earned value cost variance
*/
NumberPtr Task::getCV()
{
	VariantPtr variance = std::dynamic_pointer_cast<Variant>(getCachedValue(TaskField::TF_CV));
	if (variance == NULL)
	{
		variance = VariantPtr(new Variant(NumberHelper::getDouble(getBCWP()) - NumberHelper::getDouble(getACWP())));
		set(TaskField::TF_CV, variance);
	}
	return variance;
}

/**
* Delay , in MPX files as eg '0ed'. Use duration
*
* @return Duration
*/
DurationPtr Task::getLevelingDelay()
{
	return std::dynamic_pointer_cast<Duration2> (getCachedValue(TaskField::TF_LEVELING_DELAY));
}

/**
* The DurationPtr field is the total span of active working time for a task.
* This is generally the amount of time from the start to the finish of a task.
* The default for new tasks is 1 day (1d).
*
* @return Duration
*/
DurationPtr Task::getDuration()
{
	return std::dynamic_pointer_cast<Duration2> (getCachedValue(TaskField::TF_DURATION));
}

/**
* Retrieves the duration text of a manually scheduled task.
*
* @return duration text
*/
CString Task::getDurationText()
{
	return NumberHelper::getString(getCachedValue(TaskField::TF_DURATION_TEXT));
}

/**
* Set a duration value.
*
* @param index duration index (1-10)
* @param value duration value
*/
void Task::setDuration(int index, DurationPtr value)
{
	set(selectField(TaskFieldLists::CUSTOM_DURATION, index), value);
}

/**
* Retrieve a duration value.
*
* @param index duration index (1-10)
* @return duration value
*/
DurationPtr Task::getDuration(int index)
{
	return std::dynamic_pointer_cast<Duration2>(getCachedValue(selectField(TaskFieldLists::CUSTOM_DURATION, index)));
}

/**
* The DurationPtr Variance field contains the difference between the
* baseline duration of a task and the total duration (current estimate)
* of a task.
*
* @return Duration
*/
DurationPtr Task::getDurationVariance()
{
	DurationPtr variance = std::dynamic_pointer_cast<Duration2>(getCachedValue(TaskField::TF_DURATION_VARIANCE));
	if (variance == NULL)
	{
		DurationPtr duration = getDuration();
		DurationPtr baselineDuration = getBaselineDuration();

		if (duration && baselineDuration)
		{
			variance = Duration2::getInstance(duration->getDuration() -
				baselineDuration->convertUnits(duration->getUnits(),
					getParentFile()->getProjectHeader())->getDuration(), duration->getUnits());
			set(TaskField::TF_DURATION_VARIANCE, variance);
		}
	}
	return (variance);
}

/**
* The Early Finish field contains the earliest DatePtr that a task could
* possibly finish, based on early finish Dates of predecessor and
* successor tasks, other constraints, and any leveling delay.
*
* @return Date
*/
DatePtr Task::getEarlyFinish()
{
	return std::dynamic_pointer_cast<Date>(getCachedValue(TaskField::TF_EARLY_FINISH));
}

/**
* The Early Start field contains the earliest DatePtr that a task could
* possibly begin, based on the early start Dates of predecessor and
* successor tasks, and other constraints.
*
* @return Date
*/
DatePtr Task::getEarlyStart()
{
	return std::dynamic_pointer_cast<Date>(getCachedValue(TaskField::TF_EARLY_START));
}

/**
* The Finish field shows the DatePtr and time that a task is scheduled to
* be completed. You can enter the finish DatePtr you want, to indicate the
* DatePtr when the task should be completed. Or, you can have Microsoft
* Project calculate the finish Date.
*
* @return Date
*/
DatePtr Task::getFinish()
{
	return std::dynamic_pointer_cast<Date>(getCachedValue(TaskField::TF_FINISH));
}

/**
* Retrieves the finish text of a manually scheduled task.
*
* @return finish text
*/
CString Task::getFinishText()
{
	return NumberHelper::getString(getCachedValue(TaskField::TF_FINISH_TEXT));
}

/**
* Set a finish value.
*
* @param index finish index (1-10)
* @param value finish value
*/
void Task::setFinish(int index, DatePtr value)
{
	set(selectField(TaskFieldLists::CUSTOM_FINISH, index), value);
}

/**
* Retrieve a finish value.
*
* @param index finish index (1-10)
* @return finish value
*/
DatePtr Task::getFinish(int index)
{
	return std::dynamic_pointer_cast<Date>(getCachedValue(selectField(TaskFieldLists::CUSTOM_FINISH, index)));
}

/**
* Calculate the finish variance.
*
* @return finish variance
*/
DurationPtr Task::getFinishVariance()
{
	DurationPtr variance = std::dynamic_pointer_cast<Duration2>(getCachedValue(TaskField::TF_FINISH_VARIANCE));
	if (variance == NULL)
	{
		TimeUnit format = getParentFile()->getProjectHeader()->getDefaultDurationUnits();
		variance = DateHelper::getVariance(this, getBaselineFinish(), getFinish(), format);
		set(TaskField::TF_FINISH_VARIANCE, variance);
	}
	return (variance);
}

/**
* The Fixed Cost field shows any task expense that is not associated
* with a resource cost.
*
* @return currency amount
*/
NumberPtr Task::getFixedCost()
{
	return std::dynamic_pointer_cast<Number> (getCachedValue(TaskField::TF_FIXED_COST));
}

/**
* Set a flag value.
*
* @param index flag index (1-20)
* @param value flag value
*/
void Task::setFlag(int index, bool value)
{
	set(selectField(TaskFieldLists::CUSTOM_FLAG, index), VariantPtr(new Variant(value)));
}

/**
* Retrieve a flag value.
*
* @param index flag index (1-20)
* @return flag value
*/
bool Task::getFlag(int index)
{
	return NumberHelper::getBool(getCachedValue(selectField(TaskFieldLists::CUSTOM_FLAG, index)));
}

/**
* The Free Slack field contains the amount of time that a task can be
* delayed without delaying any successor tasks. If the task has no
* successors, free slack is the amount of time that a task can be
* delayed without delaying the entire project's finish Date.
*
* @return Duration
*/
DurationPtr Task::getFreeSlack()
{
	return std::dynamic_pointer_cast<Duration2>(getCachedValue(TaskField::TF_FREE_SLACK));
}

/**
* The Hide Bar field indicates whether the Gantt bars and CalendarPtr bars
* for a task are hidden. Click Yes in the Hide Bar field to hide the
* bar for the task. Click No in the Hide Bar field to show the bar
* for the task.
*
* @return bool
*/
bool Task::getHideBar()
{
	return NumberHelper::getBool(getCachedValue(TaskField::TF_HIDE_BAR));
}

/**
* The ID field contains the identifier number that Microsoft Project
* automatically assigns to each task as you add it to the project.
* The ID indicates the position of a task with respect to the other tasks.
*
* @return the task ID
*/
int Task::getID()
{
	ObjectPtr obj = getCachedValue(TaskField::TF_ID);
	if (obj)
		return NumberHelper::getInt(obj);
	return -1;
}

/**
* The Late Finish field contains the latest DatePtr that a task can finish
* without delaying the finish of the project. This DatePtr is based on the
* task's late start Date, as well as the late start and late finish
* Dates of predecessor and successor
* tasks, and other constraints.
*
* @return Date
*/
DatePtr Task::getLateFinish()
{
	return std::dynamic_pointer_cast<Date>(getCachedValue(TaskField::TF_LATE_FINISH));
}

/**
* The Late Start field contains the latest DatePtr that a task can start
* without delaying the finish of the project. This DatePtr is based on
* the task's start Date, as well as the late start and late finish
* Dates of predecessor and successor tasks, and other constraints.
*
* @return Date
*/
DatePtr Task::getLateStart()
{
	return std::dynamic_pointer_cast<Date>(getCachedValue(TaskField::TF_LATE_START));
}

/**
* The Linked Fields field indicates whether there are OLE links to the task,
* either from elsewhere in the active project, another Microsoft Project file,
* or from another program.
*
* @return bool
*/
bool Task::getLinkedFields()
{
	return (NumberHelper::getBool(getCachedValue(TaskField::TF_LINKED_FIELDS)));
}

/**
* The Marked field indicates whether a task is marked for further action or
* identification of some kind. To mark a task, click Yes in the Marked field.
* If you don't want a task marked, click No.
*
* @return true for marked
*/
bool Task::getMarked()
{
	return (NumberHelper::getBool(getCachedValue(TaskField::TF_MARKED)));
}

/**
* The Milestone field indicates whether a task is a milestone.
*
* @return bool
*/
bool Task::getMilestone()
{
	return (NumberHelper::getBool(getCachedValue(TaskField::TF_MILESTONE)));
}

/**
* Retrieves the task name.
*
* @return task name
*/
CString Task::getName()
{
	return NumberHelper::getString(getCachedValue(TaskField::TF_NAME));
}

/**
* The Notes field contains notes that you can enter about a task.
* You can use task notes to help maintain a history for a task.
*
* @return notes
*/
CString Task::getNotes()
{
	CString notes = NumberHelper::getString(getCachedValue(TaskField::TF_NOTES));
	//return (notes == NULL ? "" : notes);
	return notes;
}

/**
* Set a number value.
*
* @param index number index (1-20)
* @param value number value
*/
void Task::setNumber(int index, NumberPtr value)
{
	set(selectField(TaskFieldLists::CUSTOM_NUMBER, index), value);
}

/**
* Retrieve a number value.
*
* @param index number index (1-20)
* @return number value
*/
NumberPtr Task::getNumber(int index)
{
	return std::dynamic_pointer_cast<Number> (getCachedValue(selectField(TaskFieldLists::CUSTOM_NUMBER, index)));
}

/**
* The Objects field contains the number of objects attached to a task.
* Microsoft Project counts the number of objects linked or embedded to a task.
* However, objects in the Notes box in the Resource2Ptr Form are not included
* in this count.
*
* @return int
*/
int Task::getObjects()
{
	return NumberHelper::getInt(getCachedValue(TaskField::TF_OBJECTS));
}

/**
* The Outline Level field contains the number that indicates the level
* of the task in the project outline hierarchy.
*
* @return int
*/
int Task::getOutlineLevel()
{
	return NumberHelper::getInt(getCachedValue(TaskField::TF_OUTLINE_LEVEL));
}

/**
* The Outline NumberPtr field contains the number of the task in the structure
* of an outline. This number indicates the task's position within the
* hierarchical structure of the project outline. The outline number is
* similar to a WBS (work breakdown structure) number,
* except that the outline number is automatically entered by
* Microsoft Project.
*
* @return CString
*/
CString Task::getOutlineNumber()
{
	return NumberHelper::getString(getCachedValue(TaskField::TF_OUTLINE_NUMBER));
}

/**
* Retrieves the list of predecessors for this task.
*
* @return list of predecessor RelationPtr instances
*/
std::shared_ptr<List<RelationPtr>> Task::getPredecessors()
{
	return std::dynamic_pointer_cast<List<RelationPtr>> (getCachedValue(TaskField::TF_PREDECESSORS));
}

/**
* Retrieves the list of succesors for this task.
*
* @return list of successor RelationPtr instances
*/
std::shared_ptr<List<RelationPtr>> Task::getSuccessors()
{
	return std::dynamic_pointer_cast<List<RelationPtr>> (getCachedValue(TaskField::TF_SUCCESSORS));
}

/**
* The PriorityPtr field provides choices for the level of importance
* assigned to a task, which in turn indicates how readily a task can be
* delayed or split during resource leveling.
* The default priority is Medium. Those tasks with a priority
* of Do Not Level are never delayed or split when Microsoft Project levels
* tasks that have overallocated resources assigned.
*
* @return priority class instance
*/
PriorityPtr Task::getPriority()
{
	return std::dynamic_pointer_cast<Priority> (getCachedValue(TaskField::TF_PRIORITY));
}

/**
* The Project field shows the name of the project from which a task
* originated.
* This can be the name of the active project file-> If there are other
* projects inserted
* into the active project file, the name of the inserted project appears
* in this field
* for the task.
*
* @return name of originating project
*/
CString Task::getProject()
{
	return NumberHelper::getString(getCachedValue(TaskField::TF_PROJECT));
}

/**
* The Remaining Cost field shows the remaining scheduled expense of a
* task that will be incurred in completing the remaining scheduled work
* by all resources assigned to the task.
*
* @return remaining cost
*/
NumberPtr Task::getRemainingCost()
{
	return std::dynamic_pointer_cast<Number>(getCachedValue(TaskField::TF_REMAINING_COST));
}

/**
* The Remaining DurationPtr field shows the amount of time required
* to complete the unfinished portion of a task.
*
* @return Duration
*/
DurationPtr Task::getRemainingDuration()
{
	return std::dynamic_pointer_cast<Duration2>(getCachedValue(TaskField::TF_REMAINING_DURATION));
}

/**
* The Remaining Work field shows the amount of time, or person-hours,
* still required by all assigned resources to complete a task.
*
* @return the amount of time still required to complete a task
*/
DurationPtr Task::getRemainingWork()
{
	return std::dynamic_pointer_cast<Duration2>(getCachedValue(TaskField::TF_REMAINING_WORK));
}

/**
* The Resource2Ptr Group2 field contains the list of resource groups to which
* the resources assigned to a task belong.
*
* @return single string list of groups
*/
CString Task::getResource2Group2()
{
	return NumberHelper::getString(getCachedValue(TaskField::TF_RESOURCE_GROUP));
}

/**
* The Resource2Ptr Initials field lists the abbreviations for the names of
* resources assigned to a task. These initials can serve as substitutes
* for the names.
*
* Note that MS Project 98 does not export values for this field when
* writing an MPX file, and the field is not currently populated by MPXJ
* when reading an MPP file->
*
* @return CString containing a comma separated list of initials
*/
CString Task::getResource2Initials()
{
	return NumberHelper::getString(getCachedValue(TaskField::TF_RESOURCE_INITIALS));
}

/**
* The Resource2Ptr Names field lists the names of all resources assigned
* to a task.
*
* Note that MS Project 98 does not export values for this field when
* writing an MPX file, and the field is not currently populated by MPXJ
* when reading an MPP file->
*
* @return CString containing a comma separated list of names
*/
CString Task::getResource2Names()
{
	return NumberHelper::getString(getCachedValue(TaskField::TF_RESOURCE_NAMES));
}

/**
* The Resume field shows the DatePtr that the remaining portion of a task
* is scheduled to resume after you enter a new value for the % Complete
* field. The Resume field is also recalculated when the remaining portion
* of a task is moved to a new Date.
*
* @return Date
*/
DatePtr Task::getResume()
{
	return std::dynamic_pointer_cast<Date>(getCachedValue(TaskField::TF_RESUME));
}

/**
* For subtasks, the Rollup field indicates whether information on the
* subtask Gantt bars
* will be rolled up to the summary task bar. For summary tasks, the
* Rollup field indicates
* whether the summary task bar displays rolled up bars. You must
* have the Rollup field for
* summary tasks set to Yes for any subtasks to roll up to them.
*
* @return bool
*/
bool Task::getRollup()
{
	return NumberHelper::getBool(getCachedValue(TaskField::TF_ROLLUP));
}

/**
* The Start field shows the DatePtr and time that a task is scheduled to begin.
* You can enter the start DatePtr you want, to indicate the DatePtr when the task
* should begin. Or, you can have Microsoft Project calculate the start Date.
*
* @return Date
*/
DatePtr Task::getStart()
{
	return std::dynamic_pointer_cast<Date> (getCachedValue(TaskField::TF_START));
}

/**
* Retrieve the start text for a manually scheduled task.
*
* @return start text
*/
CString Task::getStartText()
{
	return NumberHelper::getString(getCachedValue(TaskField::TF_START_TEXT));
}

/**
* Set a start value.
*
* @param index start index (1-10)
* @param value start value
*/
void Task::setStart(int index, DatePtr value)
{
	set(selectField(TaskFieldLists::CUSTOM_START, index), value);
}

/**
* Retrieve a start value.
*
* @param index start index (1-10)
* @return start value
*/
DatePtr Task::getStart(int index)
{
	return std::dynamic_pointer_cast<Date>(getCachedValue(selectField(TaskFieldLists::CUSTOM_START, index)));
}

/**
* Calculate the start variance.
*
* @return start variance
*/
DurationPtr Task::getStartVariance()
{
	DurationPtr variance = std::dynamic_pointer_cast<Duration2>(getCachedValue(TaskField::TF_START_VARIANCE));
	if (variance == NULL)
	{
		TimeUnit format = getParentFile()->getProjectHeader()->getDefaultDurationUnits();
		variance = DateHelper::getVariance(this, getBaselineStart(), getStart(), format);
		set(TaskField::TF_START_VARIANCE, variance);
	}
	return (variance);
}

/**
* The Stop field shows the DatePtr that represents the end of the actual
* portion of a task. Typically, Microsoft Project calculates the stop Date.
* However, you can edit this DatePtr as well.
*
* @return Date
*/
DatePtr Task::getStop()
{
	return std::dynamic_pointer_cast<Date>(getCachedValue(TaskField::TF_STOP));
}

/**
* Contains the file name and path of the sub project represented by
* the current task.
*
* @return sub project file path
*/
CString Task::getSubprojectName()
{
	return NumberHelper::getString(getCachedValue(TaskField::TF_SUBPROJECT_FILE));
}

/**
* The Summary field indicates whether a task is a summary task.
*
* @return bool, true-is summary task
*/
bool Task::getSummary()
{
	return NumberHelper::getBool(getCachedValue(TaskField::TF_SUMMARY));
}

/**
* The SV (earned value schedule variance) field shows the difference in
* cost terms between the current progress and the baseline plan of the
* task up to the status DatePtr or today's Date. You can use SV to
* check costs to determine whether tasks are on schedule.
*
* @return -earned value schedule variance
*/
NumberPtr Task::getSV()
{
	NumberPtr variance = std::dynamic_pointer_cast<Number> (getCachedValue(TaskField::TF_SV));
	if (variance == NULL)
	{
		NumberPtr bcwp = getBCWP();
		NumberPtr bcws = getBCWS();
		if (bcwp != NULL && bcws != NULL)
		{
			variance = VariantPtr(new Variant(bcwp->doubleValue() - bcws->doubleValue()));
			set(TaskField::TF_SV, variance);
		}
	}
	return (variance);
}

/**
* Set a text value.
*
* @param index text index (1-30)
* @param value text value
*/
void Task::setText(int index, CString value)
{
	set(selectField(TaskFieldLists::CUSTOM_TEXT, index), VariantPtr(new Variant(value)));
}

/**
* Retrieve a text value.
*
* @param index text index (1-30)
* @return text value
*/
CString Task::getText(int index)
{
	return NumberHelper::getString(getCachedValue(selectField(TaskFieldLists::CUSTOM_TEXT, index)));
}

/**
* Set an outline code value.
*
* @param index outline code index (1-10)
* @param value outline code value
*/
void Task::setOutlineCode(int index, CString value)
{
	set(selectField(TaskFieldLists::CUSTOM_OUTLINE_CODE, index), VariantPtr(new Variant(value)));
}

/**
* Retrieve an outline code value.
*
* @param index outline code index (1-10)
* @return outline code value
*/
CString Task::getOutlineCode(int index)
{
	return NumberHelper::getString(getCachedValue(selectField(TaskFieldLists::CUSTOM_OUTLINE_CODE, index)));
}

/**
* The Total Slack field contains the amount of time a task can be
* delayed without delaying the project's finish Date.
*
* @return string representing duration
*/
DurationPtr Task::getTotalSlack()
{
	DurationPtr totalSlack = std::dynamic_pointer_cast<Duration2> (getCachedValue(TaskField::TF_TOTAL_SLACK));
	if (!totalSlack)
	{
		DurationPtr duration = getDuration();
		if (!duration)
		{
			duration = Duration2::getInstance(0, TimeUnit::DAYS);
		}

		TimeUnit units = duration->getUnits();

		DurationPtr startSlack = getStartSlack();
		if (!startSlack)
		{
			startSlack = Duration2::getInstance(0, units);
		}
		else
		{
			if (startSlack->getUnits() != units)
			{
				startSlack = startSlack->convertUnits(units, getParentFile()->getProjectHeader());
			}
		}

		DurationPtr finishSlack = getFinishSlack();
		if (!finishSlack)
		{
			finishSlack = Duration2::getInstance(0, units);
		}
		else
		{
			if (finishSlack->getUnits() != units)
			{
				finishSlack = finishSlack->convertUnits(units, getParentFile()->getProjectHeader());
			}
		}

		double startSlackDuration = startSlack->getDuration();
		double finishSlackDuration = finishSlack->getDuration();

		if (startSlackDuration == 0 || finishSlackDuration == 0)
		{
			if (startSlackDuration != 0)
			{
				totalSlack = startSlack;
			}
			else
			{
				totalSlack = finishSlack;
			}
		}
		else
		{
			if (startSlackDuration < finishSlackDuration)
			{
				totalSlack = startSlack;
			}
			else
			{
				totalSlack = finishSlack;
			}
		}

		set(TaskField::TF_TOTAL_SLACK, totalSlack);
	}

	return (totalSlack);
}

/**
* The Unique ID field contains the number that Microsoft Project
* automatically designates whenever a new task is created. This number
* indicates the sequence in which the task was
* created, regardless of placement in the schedule.
*
* @return CString
*/
int Task::getUniqueID()
{
	return NumberHelper::getInt(getCachedValue(TaskField::TF_UNIQUE_ID));
}

/**
* The UpDate Needed field indicates whether a TeamUpDate message
* should be sent to the assigned resources because of changes to the
* start Date, finish Date, or resource reassignments of the task.
*
* @return true if needed.
*/
bool Task::getUpDateNeeded()
{
	return NumberHelper::getBool(getCachedValue(TaskField::TF_UPDATE_NEEDED));
}

/**
* The work breakdown structure code. The WBS field contains an
* alphanumeric code you can use to represent the task's position within
* the hierarchical structure of the project. This field is similar to
* the outline number, except that you can edit it.
*
* @return string
*/
CString Task::getWBS()
{
	return NumberHelper::getString(getCachedValue(TaskField::TF_WBS));
}

/**
* The Work field shows the total amount of work scheduled to be performed
* on a task by all assigned resources. This field shows the total work,
* or person-hours, for a task.
*
* @return DurationPtr representing duration .
*/
DurationPtr Task::getWork()
{
	return std::dynamic_pointer_cast<Duration2>(getCachedValue(TaskField::TF_WORK));
}

/**
* The Work Variance field contains the difference between a task's
* baseline work and the currently scheduled work.
*
* @return DurationPtr representing duration.
*/
DurationPtr Task::getWorkVariance()
{
	DurationPtr variance = std::dynamic_pointer_cast<Duration2>(getCachedValue(TaskField::TF_WORK_VARIANCE));
	if (!variance)
	{
		DurationPtr work = getWork();
		DurationPtr baselineWork = getBaselineWork();
		if (work && baselineWork)
		{
			variance = Duration2::getInstance(work->getDuration() -
				baselineWork->convertUnits(work->getUnits(),
					getParentFile()->getProjectHeader())->getDuration(), work->getUnits());
			set(TaskField::TF_WORK_VARIANCE, variance);
		}
	}
	return (variance);
}

/**
* This method retrieves a reference to the parent of this task, as
* defined by the outline level. If this task is at the top level,
* this method will return NULL.
*
* @return parent task
*/
Task* Task::getParentTask()
{
	return m_parent;
}

/**
* This method retrieves a list of child tasks relative to the
* current task, as defined by the outine level. If there
* are no child tasks, this method will return an empty list.
*
* @return child tasks
*/
List<Task*>* Task::getChildTasks()
{
	return &m_children;
}

void Task::getAllTasks(Task* pTask, List<Task*>* pTaskList)
{
	pTaskList->Add(pTask);
	List<Task *>* childTasks = pTask->getChildTasks();
	if (childTasks == nullptr)
		return;
	for (int i=0; i<(int)childTasks->GetCount(); ++i)
	{
		Task * pAt = childTasks->GetAt(i);
		getAllTasks(pAt, pTaskList);
	}
}

/**
*	@brief    
*	@param    [in]		pTask
*	@param    [out]		pTaskList
*/
void Task::getAllParentTasks(Task* pTask, List<Task*>* pParentTaskList)
{
	if (nullptr == pTask)
		return;

	Task* pParentTask = pTask->getParentTask();
	if (nullptr == pParentTask)
		return;

	pParentTaskList->Add(pParentTask);
	getAllParentTasks(pParentTask, pParentTaskList);
}

void Task::getAllChildCount(Task* pTask, int &nCount)
{
	List<Task *>* childTasks = pTask->getChildTasks();
	int nchildCount = (int)childTasks->GetCount();
	for (int i = 0; i < nchildCount; i++)
	{
		nCount++;
		Task * pAt = childTasks->GetAt(i);
		getAllChildCount(pAt, nCount);
	}
}

// List<Task*>* Task::getAllChildTasks(Task* pTask)
// {
// 	
// 	List<Task *>* childTasks = pTask->getChildTasks();
// 	int nCount = (int)childTasks->GetCount();
// 	for (int i=0; i< nCount; i++)
// 	{
// 		Task * pChild = childTasks->GetAt(i);
// 		m_Allchildren.Add(pChild);
// 		getAllChildTasks(pChild);
// 	}
// 	return &m_Allchildren;
// }

/**
* This method implements the only method in the Comparable interface.
* This allows Tasks to be compared and sorted based on their ID value.
* Note that if the MPX/MPP file has been generated by MSP, the ID value
* will always be in the correct sequence. The Unique ID value will not
* necessarily be in the correct sequence as task insertions and deletions
* will change the order.
*
* @param o object to compare this instance with
* @return result of comparison
*/
int Task::compareTo(Task* o)
{
	int id1 = getID();
	int id2 = o->getID();
	return ((id1 < id2) ? (-1) : ((id1 == id2) ? 0 : 1));
}

/**
* This method retrieves a flag indicating whether the duration of the
* task has only been estimated.
*
* @return bool
*/
bool Task::getEstimated()
{
	return NumberHelper::getBool(getCachedValue(TaskField::TF_ESTIMATED));
}

/**
* This method retrieves a flag indicating whether the duration of the
* task has only been estimated.

* @param estimated bool flag
*/
void Task::setEstimated(bool estimated)
{
	set(TaskField::TF_ESTIMATED, VariantPtr(new Variant(estimated)));
}

/**
* This method retrieves the deadline for this task.
*
* @return Task* deadline
*/
DatePtr Task::getDeadline()
{
	return std::dynamic_pointer_cast<Date>(getCachedValue(TaskField::TF_DEADLINE));
}

/**
* This method sets the deadline for this task.
*
* @param deadline deadline Date
*/
void Task::setDeadline(DatePtr deadline)
{
	set(TaskField::TF_DEADLINE, deadline);
}

/**
* This method retrieves the task type.
*
* @return int representing the task type
*/
TaskType Task::getType()
{
	return (TaskType)NumberHelper::getInt(getCachedValue(TaskField::TF_TYPE));
}

/**
* This method sets the task type.
*
* @param type task type
*/
void Task::setType(TaskType type)
{
	set(TaskField::TF_TYPE, VariantPtr(new Variant((int)type)));
}

/**
* Retrieves the flag indicating if this is a NULL task.
*
* @return bool flag
*/
bool Task::getNull()
{
	return (m_null);
}

/**
* Sets the flag indicating if this is a NULL task.
*
* @param isNull bool flag
*/
void Task::setNull(bool isNull)
{
	m_null = isNull;
}

/**
* Retrieve the WBS level.
*
* @return WBS level
*/
CString Task::getWBSLevel()
{
	return (m_wbsLevel);
}

/**
* Set the WBS level.
*
* @param wbsLevel WBS level
*/
void Task::setWBSLevel(CString wbsLevel)
{
	m_wbsLevel = wbsLevel;
}

/**
* Retrieve the resume valid flag.
*
* @return resume valie flag
*/
bool Task::getResumeValid()
{
	return (m_resumeValid);
}

/**
* Set the resume valid flag.
*
* @param resumeValid resume valid flag
*/
void Task::setResumeValid(bool resumeValid)
{
	m_resumeValid = resumeValid;
}

/**
* Retrieve the recurring flag.
*
* @return recurring flag
*/
bool Task::getRecurring()
{
	return (NumberHelper::getBool(getCachedValue(TaskField::TF_RECURRING)));
}

/**
* Set the recurring flag.
*
* @param recurring recurring flag
*/
void Task::setRecurring(bool recurring)
{
	set(TaskField::TF_RECURRING, VariantPtr(new Variant(recurring)));
}

/**
* Retrieve the over allocated flag.
*
* @return over allocated flag
*/
bool Task::getOverAllocated()
{
	return (NumberHelper::getBool(getCachedValue(TaskField::TF_OVERALLOCATED)));
}

/**
* Set the over allocated flag.
*
* @param overAllocated over allocated flag
*/
void Task::setOverAllocated(bool overAllocated)
{
	set(TaskField::TF_OVERALLOCATED, VariantPtr(new Variant(overAllocated)));
}

/**
* Where a task in an MPP file represents a task from a subproject,
* this value will be non-zero. The value itself is the unique ID
* value shown in the parent project. To retrieve the value of the
* task unique ID in the child project, remove the top two bytes:
*
* taskID = (subprojectUniqueID & 0xFFFF)
*
* @return sub project unique task ID
*/
int Task::getSubprojectTaskUniqueID()
{
	return NumberHelper::getInt(getCachedValue(TaskField::TF_SUBPROJECT_UNIQUE_TASK_ID));
}

/**
* Sets the sub project unique task ID.
*
* @param subprojectUniqueTaskID subproject unique task ID
*/
void Task::setSubprojectTaskUniqueID(int subprojectUniqueTaskID)
{
	set(TaskField::TF_SUBPROJECT_UNIQUE_TASK_ID, VariantPtr(new Variant(subprojectUniqueTaskID)));
}

/**
* Where a task in an MPP file represents a task from a subproject,
* this value will be non-zero. The value itself is the ID
* value shown in the parent project.
*
* @return sub project task ID
*/
int Task::getSubprojectTaskID()
{
	return NumberHelper::getInt(getCachedValue(TaskField::TF_SUBPROJECT_TASK_ID));
}

/**
* Sets the sub project task ID.
*
* @param subprojectTaskID subproject task ID
*/
void Task::setSubprojectTaskID(int subprojectTaskID)
{
	set(TaskField::TF_SUBPROJECT_TASK_ID, VariantPtr(new Variant(subprojectTaskID)));
}

/**
* Sets the offset added to unique task IDs from sub projects
* to generate the task ID shown in the master project.
*
* @param offset unique ID offset
*/
void Task::setSubprojectTasksUniqueIDOffset(int offset)
{
	set(TaskField::TF_SUBPROJECT_TASKS_UNIQUEID_OFFSET, VariantPtr(new Variant(offset)));
}

/**
* Retrieves the offset added to unique task IDs from sub projects
* to generate the task ID shown in the master project.
*
* @return unique ID offset
*/
int Task::getSubprojectTasksUniqueIDOffset()
{
	return NumberHelper::getInt(getCachedValue(TaskField::TF_SUBPROJECT_TASKS_UNIQUEID_OFFSET));
}

/**
* Retrieve the subproject read only flag.
*
* @return subproject read only flag
*/
bool Task::getSubprojectReadOnly()
{
	return (NumberHelper::getBool(getCachedValue(TaskField::TF_SUBPROJECT_READ_ONLY)));
}

/**
* Set the subproject read only flag.
*
* @param subprojectReadOnly subproject read only flag
*/
void Task::setSubprojectReadOnly(bool subprojectReadOnly)
{
	set(TaskField::TF_SUBPROJECT_READ_ONLY, VariantPtr(new Variant(subprojectReadOnly)));
}

/**
* Retrieves the external task flag.
*
* @return external task flag
*/
bool Task::getExternalTask()
{
	return (NumberHelper::getBool(getCachedValue(TaskField::TF_EXTERNAL_TASK)));
}

/**
* Sets the external task flag.
*
* @param externalTask external task flag
*/
void Task::setExternalTask(bool externalTask)
{
	set(TaskField::TF_EXTERNAL_TASK, VariantPtr(new Variant(externalTask)));
}

/**
* Retrieves the external task project file name.
*
* @return external task project file name
*/
CString Task::getExternalTaskProject()
{
	return (m_externalTaskProject);
}

/**
* Sets the external task project file name.
*
* @param externalTaskProject external task project file name
*/
void Task::setExternalTaskProject(CString externalTaskProject)
{
	m_externalTaskProject = externalTaskProject;
}

/**
* Retrieve the ACWP value.
*
* @return ACWP value
*/
NumberPtr Task::getACWP()
{
	return std::dynamic_pointer_cast<Number>(getCachedValue(TaskField::TF_ACWP));
}

/**
* Set the ACWP value.
*
* @param acwp ACWP value
*/
void Task::setACWP(NumberPtr acwp)
{
	set(TaskField::TF_ACWP, acwp);
}

/**
* Retrieve the leveling delay format.
*
* @return leveling delay  format
*/
TimeUnit Task::getLevelingDelayFormat()
{
	return (m_levelingDelayFormat);
}

/**
* Set the leveling delay format.
*
* @param levelingDelayFormat leveling delay format
*/
void Task::setLevelingDelayFormat(TimeUnit levelingDelayFormat)
{
	m_levelingDelayFormat = levelingDelayFormat;
}

/**
* Retrieves the ignore resource celandar flag.
*
* @return ignore resource celandar flag
*/
bool Task::getIgnoreResource2Calendar()
{
	return (NumberHelper::getBool(getCachedValue(TaskField::TF_IGNORE_RESOURCE_CALENDAR)));
}

/**
* Sets the ignore resource celandar flag.
*
* @param ignoreResource2Calendar ignore resource celandar flag
*/
void Task::setIgnoreResource2Calendar(bool ignoreResource2Calendar)
{
	set(TaskField::TF_IGNORE_RESOURCE_CALENDAR, VariantPtr(new Variant(ignoreResource2Calendar)));
}

/**
* Retrieves the physical percent complete value.
*
* @return physical percent complete value
*/
int Task::getPhysicalPercentComplete()
{
	return NumberHelper::getInt(getCachedValue(TaskField::TF_PHYSICAL_PERCENT_COMPLETE));
}

/**
* Srts the physical percent complete value.
*
* @param physicalPercentComplete physical percent complete value
*/
void Task::setPhysicalPercentComplete(int physicalPercentComplete)
{
	set(TaskField::TF_PHYSICAL_PERCENT_COMPLETE, VariantPtr(new Variant(physicalPercentComplete)));
}

/**
* Retrieves the earned value method.
*
* @return earned value method
*/
EarnedValueMethod Task::getEarnedValueMethod()
{
	return (m_earnedValueMethod);
}

/**
* Sets the earned value method.
*
* @param earnedValueMethod earned value method
*/
void Task::setEarnedValueMethod(EarnedValueMethod earnedValueMethod)
{
	m_earnedValueMethod = earnedValueMethod;
}

/**
* Retrieves the actual work protected value.
*
* @return actual work protected value
*/
DurationPtr Task::getActualWorkProtected()
{
	return (m_actualWorkProtected);
}

/**
* Sets the actual work protected value.
*
* @param actualWorkProtected actual work protected value
*/
void Task::setActualWorkProtected(DurationPtr actualWorkProtected)
{
	m_actualWorkProtected = actualWorkProtected;
}

/**
* Retrieves the actual overtime work protected value.
*
* @return actual overtime work protected value
*/
DurationPtr Task::getActualOvertimeWorkProtected()
{
	return (m_actualOvertimeWorkProtected);
}

/**
* Sets the actual overtime work protected value.
*
* @param actualOvertimeWorkProtected actual overtime work protected value
*/
void Task::setActualOvertimeWorkProtected(DurationPtr actualOvertimeWorkProtected)
{
	m_actualOvertimeWorkProtected = actualOvertimeWorkProtected;
}

/**
* Retrieve the amount of regular work.
*
* @return amount of regular work
*/
DurationPtr Task::getRegularWork()
{
	return std::dynamic_pointer_cast<Duration2>(getCachedValue(TaskField::TF_REGULAR_WORK));
}

/**
* Set the amount of regular work.
*
* @param regularWork amount of regular work
*/
void Task::setRegularWork(DurationPtr regularWork)
{
	set(TaskField::TF_REGULAR_WORK, regularWork);
}

/**
* Sets the effort driven flag.
*
* @param flag value
*/
void Task::setEffortDriven(bool flag)
{
	set(TaskField::TF_EFFORT_DRIVEN, VariantPtr(new Variant(flag)));
}

/**
* Retrieves the effort driven flag.
*
* @return Flag value
*/
bool Task::getEffortDriven()
{
	return (NumberHelper::getBool(getCachedValue(TaskField::TF_EFFORT_DRIVEN)));
}

/**
* Set a DatePtr value.
*
* @param index DatePtr index (1-10)
* @param value DatePtr value
*/
void Task::setDate(int index, DatePtr value)
{
	set(selectField(TaskFieldLists::CUSTOM_DATE, index), value);
}

/**
* Retrieve a DatePtr value.
*
* @param index DatePtr index (1-10)
* @return DatePtr value
*/
DatePtr Task::getDate(int index)
{
	return std::dynamic_pointer_cast<Date>(getCachedValue(selectField(TaskFieldLists::CUSTOM_DATE, index)));
}

/**
* Retrieves the overtime cost.
*
* @return Cost value
*/
NumberPtr Task::getOvertimeCost()
{
	return std::dynamic_pointer_cast<Number>(getCachedValue(TaskField::TF_OVERTIME_COST));
}

/**
* Sets the overtime cost value.
*
* @param number Cost value
*/
void Task::setOvertimeCost(NumberPtr number)
{
	set(TaskField::TF_OVERTIME_COST, number);
}

/**
* Retrieves the actual overtime cost for this task.
*
* @return actual overtime cost
*/
NumberPtr Task::getActualOvertimeCost()
{
	return std::dynamic_pointer_cast<Number>(getCachedValue(TaskField::TF_ACTUAL_OVERTIME_COST));
}

/**
* Sets the actual overtime cost for this task.
*
* @param cost actual overtime cost
*/
void Task::setActualOvertimeCost(NumberPtr cost)
{
	set(TaskField::TF_ACTUAL_OVERTIME_COST, cost);
}

/**
* Retrieves the actual overtime work value.
*
* @return actual overtime work value
*/
DurationPtr Task::getActualOvertimeWork()
{
	return std::dynamic_pointer_cast<Duration2> (getCachedValue(TaskField::TF_ACTUAL_OVERTIME_WORK));
}

/**
* Sets the actual overtime work value.
*
* @param work actual overtime work value
*/
void Task::setActualOvertimeWork(DurationPtr work)
{
	set(TaskField::TF_ACTUAL_OVERTIME_WORK, work);
}

/**
* Retrieves the fixed cost accrual flag value.
*
* @return fixed cost accrual flag
*/
AccrueType Task::getFixedCostAccrual()
{
	return (AccrueType)(NumberHelper::getInt(getCachedValue(TaskField::TF_FIXED_COST_ACCRUAL)));
}

/**
* Sets the fixed cost accrual flag value.
*
* @param type fixed cost accrual type
*/
void Task::setFixedCostAccrual(AccrueType type)
{
	set(TaskField::TF_FIXED_COST_ACCRUAL, VariantPtr(new Variant((int)type)));
}

/**
* Retrieves the task hyperlink attribute.
*
* @return hyperlink attribute
*/
CString Task::getHyperlink()
{
	return NumberHelper::getString(getCachedValue(TaskField::TF_HYPERLINK));
}

/**
* Retrieves the task hyperlink address attribute.
*
* @return hyperlink address attribute
*/
CString Task::getHyperlinkAddress()
{
	return NumberHelper::getString(getCachedValue(TaskField::TF_HYPERLINK_ADDRESS));
}

/**
* Retrieves the task hyperlink sub-address attribute.
*
* @return hyperlink sub address attribute
*/
CString Task::getHyperlinkSubAddress()
{
	return NumberHelper::getString(getCachedValue(TaskField::TF_HYPERLINK_SUBADDRESS));
}

/**
* Sets the task hyperlink attribute.
*
* @param text hyperlink attribute
*/
void Task::setHyperlink(CString text)
{
	set(TaskField::TF_HYPERLINK, VariantPtr(new Variant(text)));
}

/**
* Sets the task hyperlink address attribute.
*
* @param text hyperlink address attribute
*/
void Task::setHyperlinkAddress(CString text)
{
	set(TaskField::TF_HYPERLINK_ADDRESS, VariantPtr(new Variant(text)));
}

/**
* Sets the task hyperlink sub address attribute.
*
* @param text hyperlink sub address attribute
*/
void Task::setHyperlinkSubAddress(CString text)
{
	set(TaskField::TF_HYPERLINK_SUBADDRESS, VariantPtr(new Variant(text)));
}

/**
* Retrieves the level assignments flag.
*
* @return level assignments flag
*/
bool Task::getLevelAssignments()
{
	return (NumberHelper::getBool(getCachedValue(TaskField::TF_LEVEL_ASSIGNMENTS)));
}

/**
* Sets the level assignments flag.
*
* @param flag level assignments flag
*/
void Task::setLevelAssignments(bool flag)
{
	set(TaskField::TF_LEVEL_ASSIGNMENTS, VariantPtr(new Variant(flag)));
}

/**
* Retrieves the leveling can split flag.
*
* @return leveling can split flag
*/
bool Task::getLevelingCanSplit()
{
	return (NumberHelper::getBool(getCachedValue(TaskField::TF_LEVELING_CAN_SPLIT)));
}

/**
* Sets the leveling can split flag.
*
* @param flag leveling can split flag
*/
void Task::setLevelingCanSplit(bool flag)
{
	set(TaskField::TF_LEVELING_CAN_SPLIT, VariantPtr(new Variant(flag)));
}

/**
* Retrieves the overtime work attribute.
*
* @return overtime work value
*/
DurationPtr Task::getOvertimeWork()
{
	return std::dynamic_pointer_cast<Duration2> (getCachedValue(TaskField::TF_OVERTIME_WORK));
}

/**
* Sets the overtime work attribute.
*
* @param work overtime work value
*/
void Task::setOvertimeWork(DurationPtr work)
{
	set(TaskField::TF_OVERTIME_WORK, work);
}

/**
* Retrieves the preleveled start attribute.
*
* @return preleveled start
*/
DatePtr Task::getPreleveledStart()
{
	return std::dynamic_pointer_cast<Date> (getCachedValue(TaskField::TF_PRELEVELED_START));
}

/**
* Retrieves the preleveled finish attribute.
*
* @return preleveled finish
*/
DatePtr Task::getPreleveledFinish()
{
	return std::dynamic_pointer_cast<Date> (getCachedValue(TaskField::TF_PRELEVELED_FINISH));
}

/**
* Sets the preleveled start attribute.
*
* @param DatePtr preleveled start attribute
*/
void Task::setPreleveledStart(DatePtr Date)
{
	set(TaskField::TF_PRELEVELED_START, Date);
}

/**
* Sets the preleveled finish attribute.
*
* @param DatePtr preleveled finish attribute
*/
void Task::setPreleveledFinish(DatePtr Date)
{
	set(TaskField::TF_PRELEVELED_FINISH, Date);
}

/**
* Retrieves the remaining overtime work attribute.
*
* @return remaining overtime work
*/
DurationPtr Task::getRemainingOvertimeWork()
{
	return std::dynamic_pointer_cast<Duration2>(getCachedValue(TaskField::TF_REMAINING_OVERTIME_WORK));
}

/**
* Sets the remaining overtime work attribute.
*
* @param work remaining overtime work
*/
void Task::setRemainingOvertimeWork(DurationPtr work)
{
	set(TaskField::TF_REMAINING_OVERTIME_WORK, work);
}

/**
* Retrieves the remaining overtime cost.
*
* @return remaining overtime cost value
*/
NumberPtr Task::getRemainingOvertimeCost()
{
	return std::dynamic_pointer_cast<Number>(getCachedValue(TaskField::TF_REMAINING_OVERTIME_COST));
}

/**
* Sets the remaining overtime cost value.
*
* @param cost overtime cost value
*/
void Task::setRemainingOvertimeCost(NumberPtr cost)
{
	set(TaskField::TF_REMAINING_OVERTIME_COST, cost);
}

/**
* Retrieves the base calendar instance associated with this task.
* Note that this attribute appears in MPP9 and MSPDI files.
*
* @return ProjectCalendar* instance
*/
ProjectCalendarPtr Task::getCalendar()
{
	return std::dynamic_pointer_cast<ProjectCalendar> (getCachedValue(TaskField::TF_CALENDAR));
}

/**
* Sets the name of the base calendar associated with this task.
* Note that this attribute appears in MPP9 and MSPDI files.
*
* @param calendar calendar instance
*/
void Task::setCalendar(ProjectCalendarPtr calendar)
{
	set(TaskField::TF_CALENDAR, calendar);
}

/**
* Retrieve a flag indicating if the task is shown as expanded
* in MS Project. If this flag is set to true, any sub tasks
* for this current task will be visible. If this is false,
* any sub tasks will be hidden.
*
* @return bool flag
*/
bool Task::getExpanded()
{
	return (m_expanded);
}

/**
* Set a flag indicating if the task is shown as expanded
* in MS Project. If this flag is set to true, any sub tasks
* for this current task will be visible. If this is false,
* any sub tasks will be hidden.
*
* @param expanded bool flag
*/
void Task::setExpanded(bool expanded)
{
	m_expanded = expanded;
}

/**
* Set the start slack.
*
* @param duration start slack
*/
void Task::setStartSlack(DurationPtr duration)
{
	set(TaskField::TF_START_SLACK, duration);
}

/**
* Set the finish slack.
*
* @param duration finish slack
*/
void Task::setFinishSlack(DurationPtr duration)
{
	set(TaskField::TF_FINISH_SLACK, duration);
}

/**
* Retrieve the start slack.
*
* @return start slack
*/
DurationPtr Task::getStartSlack()
{
	DurationPtr startSlack = std::dynamic_pointer_cast<Duration2> (getCachedValue(TaskField::TF_START_SLACK));
	if (startSlack == NULL)
	{
		DurationPtr duration = getDuration();
		if (duration != NULL)
		{
			startSlack = DateHelper::getVariance(this, getLateStart(), getEarlyStart(), duration->getUnits());
			set(TaskField::TF_START_SLACK, startSlack);
		}
	}
	return (startSlack);
}

/**
* Retrieve the finish slack.
*
* @return finish slack
*/
DurationPtr Task::getFinishSlack()
{
	DurationPtr finishSlack = std::dynamic_pointer_cast<Duration2> (getCachedValue(TaskField::TF_FINISH_SLACK));
	if (finishSlack == NULL)
	{
		DurationPtr duration = getDuration();
		if (duration != NULL)
		{
			finishSlack = DateHelper::getVariance(this, getLateFinish(), getEarlyFinish(), duration->getUnits());
			set(TaskField::TF_FINISH_SLACK, finishSlack);
		}
	}
	return (finishSlack);
}

/**
* Retrieve the value of a field using its alias.
*
* @param alias field alias
* @return field value
*/
ObjectPtr Task::getFieldByAlias(CString alias)
{
	return (getCachedValue(getParentFile()->getAliasTaskField(alias)));
}

/**
* Set the value of a field using its alias.
*
* @param alias field alias
* @param value field value
*/
void Task::setFieldByAlias(CString alias, ObjectPtr value)
{
	set(getParentFile()->getAliasTaskField(alias), value);
}

/**
* This method retrieves a list of task splits. Each split is represented
* by a DateRange instance. The list will always follow the pattern
* task range, split range, task range and so on.
*
* Note that this method will return NULL if the task is not split.
*
* @return list of split times
*/
DateRangeListPtr Task::getSplits()
{
	return (m_splits);
}

/**
* Internal method used to set the list of splits.
*
* @param splits list of split times
*/
void Task::setSplits(DateRangeListPtr splits)
{
	m_splits = splits;
}

/**
* Task* splits contain the time up to which the splits are completed.
*
* @return DurationPtr of completed time for the splits.
*/
DatePtr Task::getSplitCompleteDuration()
{
	return m_splitsComplete;
}

/**
* Set the time up to which the splits are completed.
*
* @param splitsComplete DurationPtr of completed time for the splits.
*/
void Task::setSplitCompleteDuration(DatePtr splitsComplete)
{
	m_splitsComplete = splitsComplete;
}

/**
* Removes this task from the project.
*/
void Task::remove()
{
	getParentFile()->removeTask(this);
}

/**
* Retrieve the sub project represented by this task.
*
* @return sub project
*/
SubProjectPtr Task::getSubProject()
{
	return (m_subProject);
}

/**
* Set the sub project represented by this task.
*
* @param subProject sub project
*/
void Task::setSubProject(SubProjectPtr subProject)
{
	m_subProject = subProject;
}

/**
* Retrieve an enterprise field value.
*
* @param index field index
* @return field value
*/
NumberPtr Task::getEnterpriseCost(int index)
{
	return std::dynamic_pointer_cast<Number> (getCachedValue(selectField(TaskFieldLists::ENTERPRISE_COST, index)));
}

/**
* Set an enterprise field value.
*
* @param index field index
* @param value field value
*/
void Task::setEnterpriseCost(int index, NumberPtr value)
{
	set(selectField(TaskFieldLists::ENTERPRISE_COST, index), value);
}

/**
* Retrieve an enterprise field value.
*
* @param index field index
* @return field value
*/
DatePtr Task::getEnterpriseDate(int index)
{
	return std::dynamic_pointer_cast<Date> (getCachedValue(selectField(TaskFieldLists::ENTERPRISE_DATE, index)));
}

/**
* Set an enterprise field value.
*
* @param index field index
* @param value field value
*/
void Task::setEnterpriseDate(int index, DatePtr value)
{
	set(selectField(TaskFieldLists::ENTERPRISE_DATE, index), value);
}

/**
* Retrieve an enterprise field value.
*
* @param index field index
* @return field value
*/
DurationPtr Task::getEnterpriseDuration(int index)
{
	return std::dynamic_pointer_cast<Duration2>(getCachedValue(selectField(TaskFieldLists::ENTERPRISE_DURATION, index)));
}

/**
* Set an enterprise field value.
*
* @param index field index
* @param value field value
*/
void Task::setEnterpriseDuration(int index, DurationPtr value)
{
	set(selectField(TaskFieldLists::ENTERPRISE_DURATION, index), value);
}

/**
* Retrieve an enterprise field value.
*
* @param index field index
* @return field value
*/
bool Task::getEnterpriseFlag(int index)
{
	return (NumberHelper::getBool(getCachedValue(selectField(TaskFieldLists::ENTERPRISE_FLAG, index))));
}

/**
* Set an enterprise field value.
*
* @param index field index
* @param value field value
*/
void Task::setEnterpriseFlag(int index, bool value)
{
	set(selectField(TaskFieldLists::ENTERPRISE_FLAG, index), VariantPtr(new Variant(value)));
}

/**
* Retrieve an enterprise field value.
*
* @param index field index
* @return field value
*/
NumberPtr Task::getEnterpriseNumber(int index)
{
	return std::dynamic_pointer_cast<Number>(getCachedValue(selectField(TaskFieldLists::ENTERPRISE_NUMBER, index)));
}

/**
* Set an enterprise field value.
*
* @param index field index
* @param value field value
*/
void Task::setEnterpriseNumber(int index, NumberPtr value)
{
	set(selectField(TaskFieldLists::ENTERPRISE_NUMBER, index), value);
}

/**
* Retrieve an enterprise field value.
*
* @param index field index
* @return field value
*/
CString Task::getEnterpriseText(int index)
{
	return NumberHelper::getString(getCachedValue(selectField(TaskFieldLists::ENTERPRISE_TEXT, index)));
}

/**
* Set an enterprise field value.
*
* @param index field index
* @param value field value
*/
void Task::setEnterpriseText(int index, CString value)
{
	set(selectField(TaskFieldLists::ENTERPRISE_TEXT, index), VariantPtr(new Variant(value)));
}

/**
* Retrieve an enterprise custom field value.
*
* @param index field index
* @return field value
*/
CString Task::getEnterpriseCustomField(int index)
{
	return NumberHelper::getString(getCachedValue(selectField(TaskFieldLists::ENTERPRISE_CUSTOM_FIELD, index)));
}

/**
* Set an enterprise custom field value.
*
* @param index field index
* @param value field value
*/
void Task::setEnterpriseCustomField(int index, CString value)
{
	set(selectField(TaskFieldLists::ENTERPRISE_CUSTOM_FIELD, index), VariantPtr(new Variant(value)));
}

/**
* Set a baseline value.
*
* @param baselineNumber baseline index (1-10)
* @param value baseline value
*/
void Task::setBaselineCost(int baselineNumber, NumberPtr value)
{
	set(selectField(TaskFieldLists::BASELINE_COSTS, baselineNumber), value);
}

/**
* Set a baseline value.
*
* @param baselineNumber baseline index (1-10)
* @param value baseline value
*/
void Task::setBaselineDuration(int baselineNumber, DurationPtr value)
{
	set(selectField(TaskFieldLists::BASELINE_DURATIONS, baselineNumber), value);
}

/**
* Set a baseline value.
*
* @param baselineNumber baseline index (1-10)
* @param value baseline value
*/
void Task::setBaselineFinish(int baselineNumber, DatePtr value)
{
	set(selectField(TaskFieldLists::BASELINE_FINISHES, baselineNumber), value);
}

/**
* Set a baseline value.
*
* @param baselineNumber baseline index (1-10)
* @param value baseline value
*/
void Task::setBaselineStart(int baselineNumber, DatePtr value)
{
	set(selectField(TaskFieldLists::BASELINE_STARTS, baselineNumber), value);
}

/**
* Set a baseline value.
*
* @param baselineNumber baseline index (1-10)
* @param value baseline value
*/
void Task::setBaselineWork(int baselineNumber, DurationPtr value)
{
	set(selectField(TaskFieldLists::BASELINE_WORKS, baselineNumber), value);
}

/**
* Retrieve a baseline value.
*
* @param baselineNumber baseline index (1-10)
* @return baseline value
*/
NumberPtr Task::getBaselineCost(int baselineNumber)
{
	return std::dynamic_pointer_cast<Number>(getCachedValue(selectField(TaskFieldLists::BASELINE_COSTS, baselineNumber)));
}

/**
* Retrieve a baseline value.
*
* @param baselineNumber baseline index (1-10)
* @return baseline value
*/
DurationPtr Task::getBaselineDuration(int baselineNumber)
{
	ObjectPtr result = getCachedValue(selectField(TaskFieldLists::BASELINE_DURATIONS, baselineNumber));
	if (!result)
	{
		result = getCachedValue(selectField(TaskFieldLists::BASELINE_ESTIMATED_DURATIONS, baselineNumber));
	}

	if (!(std::dynamic_pointer_cast<Duration2>(result)))
	{
		result.reset();
	}
	return std::dynamic_pointer_cast<Duration2>(result);
}

/**
* Retrieves the baseline duration text value.
*
* @param baselineNumber baseline number
* @return baseline duration text value
*/
CString Task::getBaselineDurationText(int baselineNumber)
{
	ObjectPtr result = getCachedValue(selectField(TaskFieldLists::BASELINE_DURATIONS, baselineNumber));
	if (!result)
	{
		result = getCachedValue(selectField(TaskFieldLists::BASELINE_ESTIMATED_DURATIONS, baselineNumber));
	}

	if (!(std::dynamic_pointer_cast<Variant>(result)))// instanceof CString))
	{
		return L"";
	}
	return result->toString();
}

/**
* Sets the baseline duration text value.
*
* @param baselineNumber baseline number
* @param value baseline duration text value
*/
void Task::setBaselineDurationText(int baselineNumber, CString value)
{
	set(selectField(TaskFieldLists::BASELINE_DURATIONS, baselineNumber), VariantPtr(new Variant(value)));
}

/**
* Retrieve a baseline value.
*
* @param baselineNumber baseline index (1-10)
* @return baseline value
*/
DatePtr Task::getBaselineFinish(int baselineNumber)
{
	ObjectPtr result = getCachedValue(selectField(TaskFieldLists::BASELINE_FINISHES, baselineNumber));
	if (!result)
	{
		result = getCachedValue(selectField(TaskFieldLists::BASELINE_ESTIMATED_FINISHES, baselineNumber));
	}

	if (!(std::dynamic_pointer_cast<Date>(result)))// instanceof Date))
	{
		result = NULL;
	}
	return std::dynamic_pointer_cast<Date>(result);
}

/**
* Retrieves the baseline finish text value.
*
* @param baselineNumber baseline number
* @return baseline finish text value
*/
CString Task::getBaselineFinishText(int baselineNumber)
{
	ObjectPtr result = getCachedValue(selectField(TaskFieldLists::BASELINE_FINISHES, baselineNumber));
	if (!result)
	{
		result = getCachedValue(selectField(TaskFieldLists::BASELINE_ESTIMATED_FINISHES, baselineNumber));
	}

	if (!(std::dynamic_pointer_cast<Variant>(result)))// instanceof CString))
	{
		return L"";
	}
	return result->toString();
}

/**
* Sets the baseline finish text value.
*
* @param baselineNumber baseline number
* @param value baseline finish text value
*/
void Task::setBaselineFinishText(int baselineNumber, CString value)
{
	set(selectField(TaskFieldLists::BASELINE_FINISHES, baselineNumber), VariantPtr(new Variant(value)));
}

/**
* Retrieve a baseline value.
*
* @param baselineNumber baseline index (1-10)
* @return baseline value
*/
DatePtr Task::getBaselineStart(int baselineNumber)
{
	ObjectPtr result = getCachedValue(selectField(TaskFieldLists::BASELINE_STARTS, baselineNumber));
	if (!result)
	{
		result = getCachedValue(selectField(TaskFieldLists::BASELINE_ESTIMATED_STARTS, baselineNumber));
	}

	if (!(std::dynamic_pointer_cast<Date>(result)))// instanceof Date))
	{
		result = NULL;
	}
	return std::dynamic_pointer_cast<Date>(result);
}

/**
* Retrieves the baseline start text value.
*
* @param baselineNumber baseline number
* @return baseline start text value
*/
CString Task::getBaselineStartText(int baselineNumber)
{
	ObjectPtr result = getCachedValue(selectField(TaskFieldLists::BASELINE_STARTS, baselineNumber));
	if (!result)
	{
		result = getCachedValue(selectField(TaskFieldLists::BASELINE_ESTIMATED_STARTS, baselineNumber));
	}

	if (!(std::dynamic_pointer_cast<Variant>(result)))// instanceof CString))
	{
		return L"";
	}
	return result->toString();
}

/**
* Sets the baseline start text value.
*
* @param baselineNumber baseline number
* @param value baseline start text value
*/
void Task::setBaselineStartText(int baselineNumber, CString value)
{
	set(selectField(TaskFieldLists::BASELINE_STARTS, baselineNumber), VariantPtr(new Variant(value)));
}

/**
* Retrieve a baseline value.
*
* @param baselineNumber baseline index (1-10)
* @return baseline value
*/
DurationPtr Task::getBaselineWork(int baselineNumber)
{
	return std::dynamic_pointer_cast<Duration2>(getCachedValue(selectField(TaskFieldLists::BASELINE_WORKS, baselineNumber)));
}

/**
* Retrieve the "complete through" Date.
*
* @return complete through Date
*/
DatePtr Task::getCompleteThrough()
{
	DatePtr value = std::dynamic_pointer_cast<Date> (getCachedValue(TaskField::TF_COMPLETE_THROUGH));
	if (!value)
	{
		int percentComplete = NumberHelper::getInt(getPercentageComplete());
		switch (percentComplete)
		{
		case 0:
		{
			break;
		}

		case 100:
		{
			value = getActualFinish();
			break;
		}

		default:
		{
			DurationPtr duration = getDuration();
			double durationValue = (duration->getDuration() * percentComplete) / 100;
			duration = Duration2::getInstance(durationValue, duration->getUnits());
			ProjectCalendarPtr calendar = getCalendar();
			if (!calendar)
			{
				calendar = getParentFile()->getCalendar();
			}
			value = calendar->getDate(getActualStart(), duration, true);
			break;
		}
		}

		set(TaskField::TF_COMPLETE_THROUGH, value);
	}
	return value;
}

/**
* Retrieve the summary progress Date.
*
* @return summary progress Date
*/
DatePtr Task::getSummaryProgress()
{
	return std::dynamic_pointer_cast<Date> (getCachedValue(TaskField::TF_SUMMARY_PROGRESS));
}

/**
* Set the summary progress Date.
*
* @param value summary progress Date
*/
void Task::setSummaryProgress(DatePtr value)
{
	set(TaskField::TF_SUMMARY_PROGRESS, value);
}

/**
* Retrieve the task GUID2.
*
* @return task GUID2
*/
LPCGUID Task::getGUID()
{
	return *std::dynamic_pointer_cast<Variant> (getCachedValue(TaskField::TF_GUID));
}

/**
* Set the task GUID2.
*
* @param value task GUID2
*/
void Task::setGUID(LPCGUID value)
{
	set(TaskField::TF_GUID, VariantPtr(new Variant(value)));
}

/**
* Retrieves the task mode.
*
* @return task mode
*/
TaskMode Task::getTaskMode()
{
	return NumberHelper::getBool(getCachedValue(TaskField::TF_TASK_MODE)) ? TaskMode::MANUALLY_SCHEDULED : TaskMode::AUTO_SCHEDULED;
}

/**
* Sets the task mode.
*
* @param mode task mode
*/
void Task::setTaskMode(TaskMode mode)
{
	set(TaskField::TF_TASK_MODE, VariantPtr(new Variant(mode == TaskMode::MANUALLY_SCHEDULED)));
}

/**
* Retrieves the active flag.
*
* @return active flag value
*/
bool Task::getActive()
{
	return NumberHelper::getBool(getCachedValue(TaskField::TF_ACTIVE));
}

/**
* Sets the active flag.
*
* @param active active flag value
*/
void Task::setActive(bool active)
{
	set(TaskField::TF_ACTIVE, VariantPtr(new Variant(active)));
}

/**
* This method allows a predecessor relationship to be removed from this
* task instance.  It will only delete relationships that exactly match the
* given targetTask, type and lag time.
*
* @param targetTask the predecessor task
* @param type relation type
* @param lag relation lag
* @return returns true if the relation is found and removed
*/
bool Task::removePredecessor(Task* targetTask, RelationType type, DurationPtr lag)
{
	bool matchFound = false;

	//
	// Retrieve the list of predecessors
	//
	std::shared_ptr<List<RelationPtr>> predecessorList = getPredecessors();
	if (predecessorList && !predecessorList->isEmpty())
	{
		//
		// Ensure that we have a valid lag duration
		//
		if (!lag)
		{
			lag = Duration2::getInstance(0, TimeUnit::DAYS);
		}

		//
		// Ensure that there is a predecessor relationship between
		// these two tasks, and remove it.
		//
		matchFound = removeRelation(predecessorList, targetTask, type, lag);

		//
		// If we have removed a predecessor, then we must remove the
		// corresponding successor entry from the target task list
		//
		if (matchFound)
		{
			//
			// Retrieve the list of successors
			//
			std::shared_ptr<List<RelationPtr>> successorList = targetTask->getSuccessors();
			if (successorList && !successorList->isEmpty())
			{
				//
				// Ensure that there is a successor relationship between
				// these two tasks, and remove it.
				//
				removeRelation(successorList, this, type, lag);
			}
		}
	}

	return matchFound;
}

/**
* Internal method used to locate an remove an item from a list Relations.
*
* @param relationList list of RelationPtr instances
* @param targetTask target relationship task
* @param type target relationship type
* @param lag target relationship lag
* @return true if a relationship was removed
*/
bool Task::removeRelation(std::shared_ptr<List<RelationPtr>> relationList,
	Task* targetTask, RelationType type, DurationPtr lag)
{
	bool matchFound = false;
	for (size_t i = 0; i < relationList->GetCount(); i++)
	{
		RelationPtr relation = relationList->GetAt(i);
		if (relation->getTargetTask() == targetTask)
		{
			if (relation->getType() == type && relation->getLag()->compareTo(lag.get()) == 0)
			{
				matchFound = relationList->remove(relation);
				break;
			}
		}
	}
	return matchFound;
}

/**
* Maps a field index to a TaskField instance.
*
* @param fields array of fields used as the basis for the mapping.
* @param index required field index
* @return TaskField instance
*/
TaskField Task::selectField(const TaskField fields[], int index)
{
	if (index < 1)// || index > fields.length)
	{
		throw std::bad_exception();// new IllegalArgumentException(index + " is not a valid field index");
	}
	return (fields[index - 1]);
}

/**
* {@inheritDoc}
*/
ObjectPtr Task::getCachedValue(FieldType* field)
{
	return (field == NULL ? NULL : m_array[field->getValue()]);
}

ObjectPtr Task::getCachedValue(TaskField field)
{
	return getCachedValue(TaskFieldClass::getInstance(field));
}

/**
* {@inheritDoc}
*/
ObjectPtr Task::getCurrentValue(FieldType* field)
{
	ObjectPtr result;

	if (field != NULL)
	{
		switch ((TaskField)field->getValue())
		{
		case TF_START_VARIANCE:
		{
			result = getStartVariance();
			break;
		}

		case TF_COST_VARIANCE:
		{
			result = getCostVariance();
			break;
		}

		case TF_DURATION_VARIANCE:
		{
			result = getDurationVariance();
			break;
		}

		case TF_WORK_VARIANCE:
		{
			result = getWorkVariance();
			break;
		}

		case TF_CV:
		{
			result = getCV();
			break;
		}

		case TF_SV:
		{
			result = getSV();
			break;
		}

		case TF_TOTAL_SLACK:
		{
			result = getTotalSlack();
			break;
		}

		case TF_CRITICAL:
		{
			result = VariantPtr(new Variant(getCritical()));
			break;
		}

		case TF_COMPLETE_THROUGH:
		{
			result = getCompleteThrough();
			break;
		}

		default:
		{
			result = m_array[field->getValue()];
			break;
		}
		}
	}

	return (result);
}

/**
* {@inheritDoc}
*/
void Task::set(FieldType* field, ObjectPtr value)
{
	if (field != NULL)
	{
		int index = field->getValue();
		if (m_eventsEnabled)
		{
			fireFieldChangeEvent((TaskField)field->getValue(), m_array[index], value);
		}

		m_array[index] = value;
	}
}

void Task::set(TaskField field, ObjectPtr value)
{
	set(TaskFieldClass::getInstance(field), value);
}

/**
* Handle the change in a field value. Reset any cached calculated
* values affected by this change, pass on the event to any external
* listeners.
*
* @param field field changed
* @param oldValue old field value
* @param newValue new field value
*/
void Task::fireFieldChangeEvent(TaskField field, ObjectPtr oldValue, ObjectPtr newValue)
{
	//
	// Internal event handling
	//
	switch (field)
	{
	case TF_START:
	{
		break;
	}
	case TF_BASELINE_START:
	{
		m_array[TaskField::TF_START_VARIANCE] = NULL;
		break;
	}

	case TF_FINISH:
	{
		break;
	}
	case TF_BASELINE_FINISH:
	{
		m_array[TaskField::TF_FINISH_VARIANCE] = NULL;
		break;
	}

	case TF_COST:
	case TF_BASELINE_COST:
	{
		m_array[TaskField::TF_COST_VARIANCE] = NULL;
		break;
	}

	case TF_DURATION:
	{
		m_array[TaskField::TF_DURATION_VARIANCE] = NULL;
		m_array[TaskField::TF_COMPLETE_THROUGH] = NULL;
		break;
	}

	case TF_BASELINE_DURATION:
	{
		m_array[TaskField::TF_DURATION_VARIANCE] = NULL;
		break;
	}

	case TF_WORK:
	{
		break;
	}
	case TF_BASELINE_WORK:
	{
		m_array[TaskField::TF_WORK_VARIANCE] = NULL;
		break;
	}

	case TF_BCWP:
	case TF_ACWP:
	{
		m_array[TaskField::TF_CV] = NULL;
		m_array[TaskField::TF_SV] = NULL;
		break;
	}

	case TF_BCWS:
	{
		m_array[TaskField::TF_SV] = NULL;
		break;
	}

	case TF_START_SLACK:
	case TF_FINISH_SLACK:
	{
		m_array[TaskField::TF_TOTAL_SLACK] = NULL;
		m_array[TaskField::TF_CRITICAL] = NULL;
		break;
	}

	case TF_EARLY_FINISH:
	case TF_LATE_FINISH:
	{
		m_array[TaskField::TF_FINISH_SLACK] = NULL;
		m_array[TaskField::TF_TOTAL_SLACK] = NULL;
		m_array[TaskField::TF_CRITICAL] = NULL;
		break;
	}

	case TF_EARLY_START:
	case TF_LATE_START:
	{
		m_array[TaskField::TF_START_SLACK] = NULL;
		m_array[TaskField::TF_TOTAL_SLACK] = NULL;
		m_array[TaskField::TF_CRITICAL] = NULL;
		break;
	}

	case TF_ACTUAL_START:
	case TF_PERCENT_COMPLETE:
	{
		m_array[TaskField::TF_COMPLETE_THROUGH] = NULL;
		break;
	}

	default:
	{
		break;
	}
	}

	//
	// External event handling
	//
	for (size_t i = 0; i < m_listeners.GetCount(); i++)
	{
		FieldListener* listener = m_listeners[i];
		listener->fieldChange(this, TaskFieldClass::getInstance(field), oldValue, newValue);
	}
}

/**
* {@inheritDoc}
*/
void Task::addFieldListener(FieldListener* listener)
{
	m_listeners.Add(listener);
}

/**
* {@inheritDoc}
*/
void Task::removeFieldListener(FieldListener* listener)
{
	m_listeners.remove(listener);
}

/**
* This method inserts a name value pair into internal storage.
*
* @param field task field
* @param value attribute value
*/
void Task::set(FieldType* field, bool value)
{
	set(field, VariantPtr(new Variant(value ? true : false)));
}

///**
//* {@inheritDoc}
//*/
//CString Task::toString()
//{
//    return ("[Task* id=" + getID() + " uniqueID=" + getUniqueID() + " name=" + getName() + (getExternalTask() ? " [EXTERNAL uid=" + getSubprojectTaskUniqueID() + " id=" + getSubprojectTaskID() + "]" : "]") + (getSubProject() == NULL ? "" : (" project=" + getSubProject())));
//}

/**
* Utility method used to determine if the supplied task
* is a predecessor of the current task.
*
* @param task potential predecessor task
* @return bool flag
*/
bool Task::isPredecessor(Task* task)
{
	return isRelated(task, getPredecessors());
}

/**
* Utility method used to determine if the supplied task
* is a successor of the current task.
*
* @param task potential successor task
* @return bool flag
*/
bool Task::isSucessor(Task* task)
{
	return isRelated(task, getSuccessors());
}

/**
* Internal method used to test for the existence of a relationship
* with a task.
*
* @param task target task
* @param list list of relationships
* @return bool flag
*/
bool Task::isRelated(Task* task, std::shared_ptr<List<RelationPtr>> list)
{
	bool result = false;

	for (size_t i = 0; list && i < list->GetCount(); i++)
	{
		RelationPtr relation = list->GetAt(i);
		if (relation->getTargetTask()->getUniqueID() == task->getUniqueID())
		{
			result = true;
			break;
		}
	}

	return result;
}

/**
* Disable events firing when fields are upDated.
*/
void Task::disableEvents()
{
	m_eventsEnabled = false;
}

/**
* Enable events firing when fields are upDated. This is the default state.
*/
void Task::enableEvents()
{
	m_eventsEnabled = true;
}